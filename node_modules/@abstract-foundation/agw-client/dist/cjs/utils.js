"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.VALID_CHAINS = void 0;
exports.convertBigIntToString = convertBigIntToString;
exports.getSmartAccountAddressFromInitialSigner = getSmartAccountAddressFromInitialSigner;
exports.isAGWAccount = isAGWAccount;
exports.isSmartAccountDeployed = isSmartAccountDeployed;
exports.getInitializerCalldata = getInitializerCalldata;
exports.transformHexValues = transformHexValues;
exports.isEip712TypedData = isEip712TypedData;
exports.transformEip712TypedData = transformEip712TypedData;
const viem_1 = require("viem");
const accounts_1 = require("viem/accounts");
const chains_1 = require("viem/chains");
const AccountFactory_js_1 = require("./abis/AccountFactory.js");
const AGWRegistryAbi_js_1 = require("./abis/AGWRegistryAbi.js");
const constants_js_1 = require("./constants.js");
const eip712_js_1 = require("./eip712.js");
exports.VALID_CHAINS = {
    [chains_1.abstractTestnet.id]: chains_1.abstractTestnet,
    [chains_1.abstract.id]: chains_1.abstract,
};
function convertBigIntToString(value) {
    if (typeof value === 'bigint') {
        return value.toString();
    }
    else if (Array.isArray(value)) {
        return value.map(convertBigIntToString);
    }
    else if (typeof value === 'object' && value !== null) {
        return Object.fromEntries(Object.entries(value).map(([key, val]) => [
            key,
            convertBigIntToString(val),
        ]));
    }
    return value;
}
async function getSmartAccountAddressFromInitialSigner(initialSigner, publicClient) {
    if (initialSigner === undefined) {
        throw new Error('Initial signer is required to get smart account address');
    }
    const addressBytes = (0, viem_1.toBytes)(initialSigner);
    const salt = (0, viem_1.keccak256)(addressBytes);
    const accountAddress = (await publicClient.readContract({
        address: constants_js_1.SMART_ACCOUNT_FACTORY_ADDRESS,
        abi: AccountFactory_js_1.default,
        functionName: 'getAddressForSalt',
        args: [salt],
    }));
    return accountAddress;
}
async function isAGWAccount(publicClient, address) {
    return await publicClient.readContract({
        address: constants_js_1.AGW_REGISTRY_ADDRESS,
        abi: AGWRegistryAbi_js_1.AGWRegistryAbi,
        functionName: 'isAGW',
        args: [address],
    });
}
async function isSmartAccountDeployed(publicClient, address) {
    const bytecode = await publicClient.getCode({
        address: address,
    });
    return bytecode !== undefined;
}
function getInitializerCalldata(initialOwnerAddress, validatorAddress, initialCall) {
    return (0, viem_1.encodeFunctionData)({
        abi: [
            {
                name: 'initialize',
                type: 'function',
                inputs: [
                    { name: 'initialK1Owner', type: 'address' },
                    { name: 'initialK1Validator', type: 'address' },
                    { name: 'modules', type: 'bytes[]' },
                    {
                        name: 'initCall',
                        type: 'tuple',
                        components: [
                            { name: 'target', type: 'address' },
                            { name: 'allowFailure', type: 'bool' },
                            { name: 'value', type: 'uint256' },
                            { name: 'callData', type: 'bytes' },
                        ],
                    },
                ],
                outputs: [],
                stateMutability: 'nonpayable',
            },
        ],
        functionName: 'initialize',
        args: [initialOwnerAddress, validatorAddress, [], initialCall],
    });
}
function transformHexValues(transaction, keys) {
    if (!transaction)
        return;
    for (const key of keys) {
        if ((0, viem_1.isHex)(transaction[key])) {
            transaction[key] = (0, viem_1.fromHex)(transaction[key], 'bigint');
        }
    }
}
function isEip712TypedData(typedData) {
    return (typedData.message &&
        typedData.domain?.name === 'zkSync' &&
        typedData.domain?.version === '2' &&
        (0, eip712_js_1.isEIP712Transaction)(typedData.message));
}
function transformEip712TypedData(typedData) {
    if (!isEip712TypedData(typedData)) {
        throw new viem_1.BaseError('Typed data is not an EIP712 transaction');
    }
    if (typedData.domain?.chainId === undefined) {
        throw new viem_1.BaseError('Chain ID is required for EIP712 transaction');
    }
    return {
        chainId: Number(typedData.domain.chainId),
        account: (0, accounts_1.parseAccount)((0, viem_1.toHex)(BigInt(typedData.message['from']), {
            size: 20,
        })),
        to: (0, viem_1.toHex)(BigInt(typedData.message['to']), {
            size: 20,
        }),
        gas: BigInt(typedData.message['gasLimit']),
        gasPerPubdata: BigInt(typedData.message['gasPerPubdataByteLimit']),
        maxFeePerGas: BigInt(typedData.message['maxFeePerGas']),
        maxPriorityFeePerGas: BigInt(typedData.message['maxPriorityFeePerGas']),
        paymaster: typedData.message['paymaster'] != '0'
            ? (0, viem_1.toHex)(BigInt(typedData.message['paymaster']), {
                size: 20,
            })
            : undefined,
        nonce: typedData.message['nonce'],
        value: BigInt(typedData.message['value']),
        data: typedData.message['data'] === '0x0'
            ? '0x'
            : typedData.message['data'],
        factoryDeps: typedData.message['factoryDeps'],
        paymasterInput: typedData.message['paymasterInput'] !== '0x'
            ? typedData.message['paymasterInput']
            : undefined,
    };
}
//# sourceMappingURL=utils.js.map