"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sendTransactionInternal = sendTransactionInternal;
const actions_1 = require("viem/actions");
const utils_1 = require("viem/utils");
const constants_js_1 = require("../constants.js");
const account_js_1 = require("../errors/account.js");
const insufficientBalance_js_1 = require("../errors/insufficientBalance.js");
const prepareTransaction_js_1 = require("./prepareTransaction.js");
const signTransaction_js_1 = require("./signTransaction.js");
async function sendTransactionInternal(client, signerClient, publicClient, parameters, validator, validationHookData = {}, customPaymasterHandler = undefined) {
    const { chain = client.chain } = parameters;
    if (!signerClient.account)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/wallet/sendTransaction',
        });
    const account = (0, utils_1.parseAccount)(signerClient.account);
    try {
        const request = await (0, prepareTransaction_js_1.prepareTransactionRequest)(client, signerClient, publicClient, {
            ...parameters,
            parameters: ['gas', 'nonce', 'fees'],
        });
        let chainId;
        if (chain !== null) {
            chainId = await (0, utils_1.getAction)(signerClient, actions_1.getChainId, 'getChainId')({});
            (0, utils_1.assertCurrentChain)({
                currentChainId: chainId,
                chain,
            });
        }
        const serializedTransaction = await (0, signTransaction_js_1.signTransaction)(client, signerClient, publicClient, {
            ...request,
            chainId,
        }, validator, validationHookData, customPaymasterHandler);
        return await (0, utils_1.getAction)(client, actions_1.sendRawTransaction, 'sendRawTransaction')({
            serializedTransaction,
        });
    }
    catch (err) {
        if (err instanceof Error &&
            err.message.includes(constants_js_1.INSUFFICIENT_BALANCE_SELECTOR)) {
            throw new insufficientBalance_js_1.InsufficientBalanceError();
        }
        throw (0, utils_1.getTransactionError)(err, {
            ...parameters,
            account,
            chain: chain,
        });
    }
}
//# sourceMappingURL=sendTransactionInternal.js.map