"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.linkToAgw = linkToAgw;
const abitype_1 = require("abitype");
const viem_1 = require("viem");
const actions_1 = require("viem/actions");
const utils_1 = require("viem/utils");
const zksync_1 = require("viem/zksync");
const BridgeHubAbi_js_1 = require("../abis/BridgeHubAbi.js");
const DelegateRegistry_js_1 = require("../abis/DelegateRegistry.js");
const ZkSyncAbi_js_1 = require("../abis/ZkSyncAbi.js");
const constants_js_1 = require("../constants.js");
const account_js_1 = require("../errors/account.js");
const utils_js_1 = require("../utils.js");
async function linkToAgw(client, parameters) {
    const { account: account_ = client.account, agwAddress, enabled, l2Chain, } = parameters;
    if (!account_) {
        throw new account_js_1.AccountNotFoundError();
    }
    const account = (0, utils_1.parseAccount)(account_);
    if (!utils_js_1.VALID_CHAINS[l2Chain.id]) {
        throw new abitype_1.BaseError('Unsupported L2 Chain');
    }
    const bridgehubAddress = constants_js_1.BRIDGEHUB_ADDRESS[l2Chain.id];
    const l1PublicClient = (0, viem_1.createPublicClient)({
        chain: client.chain,
        transport: (0, viem_1.http)(),
    });
    const l2PublicClient = (0, viem_1.createPublicClient)({
        chain: l2Chain,
        transport: (0, viem_1.http)(),
    }).extend((0, zksync_1.publicActionsL2)());
    const l2Value = 0n;
    const operatorTip = 0n;
    const l2Calldata = (0, viem_1.encodeFunctionData)({
        abi: DelegateRegistry_js_1.DelegateRegistryAbi,
        functionName: 'delegateAll',
        args: [agwAddress, constants_js_1.NON_EXPIRING_DELEGATION_RIGHTS, enabled],
    });
    const l2GasLimit = await l2PublicClient.estimateGasL1ToL2({
        chain: l2PublicClient.chain,
        account: account.address,
        to: constants_js_1.CANONICAL_DELEGATE_REGISTRY_ADDRESS,
        data: l2Calldata,
        value: 0n,
    });
    const baseFee = await l1PublicClient.getGasPrice();
    const maxPriorityFeePerGas = await l1PublicClient.estimateMaxPriorityFeePerGas();
    const maxFeePerGas = (baseFee * 3n) / 2n + maxPriorityFeePerGas;
    const gasPriceForEstimation = maxFeePerGas;
    const baseCost = await l1PublicClient.readContract({
        address: bridgehubAddress,
        abi: BridgeHubAbi_js_1.BridgeHubAbi,
        functionName: 'l2TransactionBaseCost',
        args: [
            BigInt(l2PublicClient.chain.id),
            gasPriceForEstimation,
            l2GasLimit,
            constants_js_1.BASE_GAS_PER_PUBDATA_BYTE,
        ],
    });
    const l2Costs = baseCost + operatorTip + l2Value;
    const providedValue = l2Costs;
    if (baseCost > providedValue) {
        console.error('Base cost is greater than provided value');
    }
    const bridgeArgs = {
        chainId: BigInt(l2PublicClient.chain.id),
        mintValue: providedValue,
        l2Contract: constants_js_1.CANONICAL_DELEGATE_REGISTRY_ADDRESS,
        l2Value,
        l2Calldata,
        l2GasLimit,
        l2GasPerPubdataByteLimit: constants_js_1.BASE_GAS_PER_PUBDATA_BYTE,
        factoryDeps: [],
        refundRecipient: agwAddress,
    };
    const l1TransactionHash = await (0, utils_1.getAction)(client, actions_1.writeContract, 'writeContract')({
        abi: BridgeHubAbi_js_1.BridgeHubAbi,
        address: bridgehubAddress,
        chain: client.chain,
        account,
        functionName: 'requestL2TransactionDirect',
        value: providedValue,
        args: [bridgeArgs],
        maxFeePerGas,
        maxPriorityFeePerGas,
    });
    return {
        l1TransactionHash,
        getL2TransactionHash: async () => getL2HashFromPriorityOp(l1PublicClient, l1TransactionHash),
    };
}
async function getL2HashFromPriorityOp(publicClient, l1TransactionHash) {
    const receipt = await publicClient.waitForTransactionReceipt({
        hash: l1TransactionHash,
    });
    if (receipt.status !== 'success') {
        throw new abitype_1.BaseError('L1 transaction failed');
    }
    let hash;
    for (const log of receipt.logs) {
        try {
            const priorityQueueLog = (0, viem_1.decodeEventLog)({
                abi: ZkSyncAbi_js_1.ZkSyncAbi,
                data: log.data,
                topics: log.topics,
                strict: false,
            });
            if (priorityQueueLog && priorityQueueLog.args.txHash !== null)
                hash = priorityQueueLog.args.txHash;
        }
        catch (_e) {
        }
    }
    if (!hash) {
        throw new abitype_1.BaseError('Error getting L2 hash from L1 transaction');
    }
    return hash;
}
//# sourceMappingURL=linkToAgw.js.map