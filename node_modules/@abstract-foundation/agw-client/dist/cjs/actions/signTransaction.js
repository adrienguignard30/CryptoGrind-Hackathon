"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signTransaction = signTransaction;
exports.signEip712TransactionInternal = signEip712TransactionInternal;
const viem_1 = require("viem");
const actions_1 = require("viem/actions");
const utils_1 = require("viem/utils");
const AGWAccount_js_1 = require("../abis/AGWAccount.js");
const eip712_js_1 = require("../eip712.js");
const account_js_1 = require("../errors/account.js");
const sessionValidator_js_1 = require("../sessionValidator.js");
const utils_js_1 = require("../utils.js");
const utils_js_2 = require("../utils.js");
const sendPrivyTransaction_js_1 = require("./sendPrivyTransaction.js");
async function signTransaction(client, signerClient, publicClient, args, validator, validationHookData = {}, customPaymasterHandler = undefined, isPrivyCrossApp = false) {
    const chain = client.chain;
    if (isPrivyCrossApp) {
        return (0, sendPrivyTransaction_js_1.signPrivyTransaction)(client, args);
    }
    if (!chain?.serializers?.transaction)
        throw new viem_1.BaseError('transaction serializer not found on chain.');
    const { transaction, customSignature } = await signEip712TransactionInternal(client, signerClient, publicClient, args, validator, validationHookData, customPaymasterHandler);
    return chain.serializers.transaction({
        ...transaction,
        customSignature,
        type: 'eip712',
    }, { r: '0x0', s: '0x0', v: 0n });
}
async function signEip712TransactionInternal(client, signerClient, publicClient, args, validator, validationHookData = {}, customPaymasterHandler = undefined) {
    const { account: account_ = client.account, chain = client.chain, ...transaction } = args;
    transaction.type = 'eip712';
    (0, utils_js_2.transformHexValues)(transaction, [
        'value',
        'nonce',
        'maxFeePerGas',
        'maxPriorityFeePerGas',
        'gas',
        'chainId',
        'gasPerPubdata',
    ]);
    if (!account_)
        throw new account_js_1.AccountNotFoundError({
            docsPath: '/docs/actions/wallet/signTransaction',
        });
    const smartAccount = (0, utils_1.parseAccount)(account_);
    const useSignerAddress = transaction.from === signerClient.account.address;
    const fromAccount = useSignerAddress ? signerClient.account : smartAccount;
    (0, eip712_js_1.assertEip712Request)({
        account: fromAccount,
        chain,
        ...transaction,
    });
    if (!chain || utils_js_1.VALID_CHAINS[chain.id] === undefined) {
        throw new viem_1.BaseError('Invalid chain specified');
    }
    if (!chain?.custom?.getEip712Domain)
        throw new viem_1.BaseError('`getEip712Domain` not found on chain.');
    const chainId = await (0, utils_1.getAction)(client, actions_1.getChainId, 'getChainId')({});
    if (chain !== null)
        (0, utils_1.assertCurrentChain)({
            currentChainId: chainId,
            chain: chain,
        });
    await (0, sessionValidator_js_1.assertSessionKeyPolicies)(publicClient, chainId, fromAccount, transaction);
    const transactionWithPaymaster = await getTransactionWithPaymasterData(chainId, fromAccount, transaction, customPaymasterHandler);
    if (transactionWithPaymaster.data === undefined) {
        transactionWithPaymaster.data = '0x';
    }
    const eip712Domain = chain?.custom.getEip712Domain({
        ...transactionWithPaymaster,
        type: 'eip712',
    });
    const rawSignature = await (0, actions_1.signTypedData)(signerClient, {
        ...eip712Domain,
        account: signerClient.account,
    });
    let signature;
    if (useSignerAddress) {
        signature = rawSignature;
    }
    else {
        const hookData = [];
        if (!useSignerAddress) {
            const validationHooks = await (0, utils_1.getAction)(client, actions_1.readContract, 'readContract')({
                address: client.account.address,
                abi: AGWAccount_js_1.default,
                functionName: 'listHooks',
                args: [true],
            });
            for (const hook of validationHooks) {
                hookData.push(validationHookData[hook] ?? '0x');
            }
        }
        signature = (0, viem_1.encodeAbiParameters)((0, viem_1.parseAbiParameters)(['bytes', 'address', 'bytes[]']), [rawSignature, validator, hookData]);
    }
    return {
        transaction: transactionWithPaymaster,
        customSignature: signature,
    };
}
async function getTransactionWithPaymasterData(chainId, fromAccount, transaction, customPaymasterHandler = undefined) {
    if (customPaymasterHandler &&
        !transaction.paymaster &&
        !transaction.paymasterInput) {
        const paymasterResult = await customPaymasterHandler({
            chainId,
            from: fromAccount.address,
            data: transaction.data,
            gas: transaction.gas ?? 0n,
            gasPrice: transaction.gasPrice ?? 0n,
            gasPerPubdata: transaction.gasPerPubdata ?? 0n,
            maxFeePerGas: transaction.maxFeePerGas ?? 0n,
            maxPriorityFeePerGas: transaction.maxPriorityFeePerGas ?? 0n,
            nonce: transaction.nonce ?? 0,
            to: transaction.to ?? '0x0',
            value: transaction.value ?? 0n,
        });
        return {
            ...transaction,
            ...paymasterResult,
            from: fromAccount.address,
            chainId,
        };
    }
    return {
        ...transaction,
        from: fromAccount.address,
        chainId,
    };
}
//# sourceMappingURL=signTransaction.js.map