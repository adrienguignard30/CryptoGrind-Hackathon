"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.signTypedData = signTypedData;
exports.signTypedDataForSession = signTypedDataForSession;
const viem_1 = require("viem");
const constants_js_1 = require("../constants.js");
const getAgwTypedSignature_js_1 = require("../getAgwTypedSignature.js");
const sessions_js_1 = require("../sessions.js");
const utils_js_1 = require("../utils.js");
const sendPrivyTransaction_js_1 = require("./sendPrivyTransaction.js");
const signTransaction_js_1 = require("./signTransaction.js");
async function signTypedData(client, signerClient, publicClient, parameters, isPrivyCrossApp = false) {
    if ((0, utils_js_1.isEip712TypedData)(parameters)) {
        const transformedTypedData = (0, utils_js_1.transformEip712TypedData)(parameters);
        if (transformedTypedData.chainId !== client.chain.id) {
            throw new viem_1.BaseError('Chain ID mismatch in AGW typed signature');
        }
        const signedTransaction = await (0, signTransaction_js_1.signTransaction)(client, signerClient, publicClient, {
            ...transformedTypedData,
            chain: client.chain,
        }, constants_js_1.EOA_VALIDATOR_ADDRESS, {}, undefined, isPrivyCrossApp);
        if (!signedTransaction.startsWith('0x71')) {
            throw new viem_1.BaseError('Expected RLP encoded EIP-712 transaction as signature');
        }
        const rlpSignature = `0x${signedTransaction.slice(4)}`;
        const signatureParts = (0, viem_1.fromRlp)(rlpSignature, 'hex');
        if (signatureParts.length < 15) {
            throw new viem_1.BaseError('Expected RLP encoded EIP-712 transaction with at least 15 fields');
        }
        return signatureParts[14];
    }
    else if (isPrivyCrossApp) {
        return await (0, sendPrivyTransaction_js_1.sendPrivySignTypedData)(client, parameters);
    }
    return await (0, getAgwTypedSignature_js_1.getAgwTypedSignature)({
        client,
        signer: signerClient,
        messageHash: (0, viem_1.hashTypedData)(parameters),
    });
}
async function signTypedDataForSession(client, signerClient, publicClient, parameters, session, paymasterHandler) {
    if (!(0, utils_js_1.isEip712TypedData)(parameters)) {
        throw new viem_1.BaseError('Session client can only sign EIP712 transactions as typed data');
    }
    const transactionRequest = (0, utils_js_1.transformEip712TypedData)(parameters);
    if (!transactionRequest.to) {
        throw new viem_1.BaseError('Transaction must have a to address');
    }
    const validationHookData = {
        [constants_js_1.SESSION_KEY_VALIDATOR_ADDRESS]: (0, sessions_js_1.encodeSessionWithPeriodIds)(session, (0, sessions_js_1.getPeriodIdsForTransaction)({
            sessionConfig: session,
            target: transactionRequest.to,
            selector: (transactionRequest.data?.slice(0, 10) ?? '0x'),
            timestamp: BigInt(Math.floor(Date.now() / 1000)),
        })),
    };
    const { customSignature } = await (0, signTransaction_js_1.signEip712TransactionInternal)(client, signerClient, publicClient, {
        chain: client.chain,
        ...transactionRequest,
    }, constants_js_1.SESSION_KEY_VALIDATOR_ADDRESS, validationHookData, paymasterHandler);
    return customSignature;
}
//# sourceMappingURL=signTypedData.js.map