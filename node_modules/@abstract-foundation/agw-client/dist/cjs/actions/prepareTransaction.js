"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.MaxFeePerGasTooLowError = exports.defaultParameters = void 0;
exports.prepareTransactionRequest = prepareTransactionRequest;
const viem_1 = require("viem");
const actions_1 = require("viem/actions");
const utils_1 = require("viem/utils");
const zksync_1 = require("viem/zksync");
const constants_js_1 = require("../constants.js");
const constants_js_2 = require("../exports/constants.js");
const utils_js_1 = require("../utils.js");
const utils_js_2 = require("../utils.js");
exports.defaultParameters = [
    'blobVersionedHashes',
    'chainId',
    'fees',
    'gas',
    'nonce',
    'type',
];
class MaxFeePerGasTooLowError extends viem_1.BaseError {
    constructor({ maxPriorityFeePerGas }) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${(0, viem_1.formatGwei)(maxPriorityFeePerGas)} gwei).`, { name: 'MaxFeePerGasTooLowError' });
    }
}
exports.MaxFeePerGasTooLowError = MaxFeePerGasTooLowError;
async function prepareTransactionRequest(client, signerClient, publicClient, args) {
    const { chain, gas, nonce, parameters: parameterNames = exports.defaultParameters, } = args;
    const isDeployed = await (0, utils_js_1.isSmartAccountDeployed)(publicClient, client.account.address);
    if (!isDeployed) {
        const initialCall = {
            target: args.to,
            allowFailure: false,
            value: args.value ?? 0,
            callData: args.data ?? '0x',
        };
        const initializerCallData = (0, utils_js_2.getInitializerCalldata)(signerClient.account.address, constants_js_1.EOA_VALIDATOR_ADDRESS, initialCall);
        const addressBytes = (0, viem_1.toBytes)(signerClient.account.address);
        const salt = (0, viem_1.keccak256)(addressBytes);
        const deploymentCalldata = (0, viem_1.encodeFunctionData)({
            abi: constants_js_2.AccountFactoryAbi,
            functionName: 'deployAccount',
            args: [salt, initializerCallData],
        });
        args.to = constants_js_1.SMART_ACCOUNT_FACTORY_ADDRESS;
        args.data = deploymentCalldata;
    }
    const initiatorAccount = (0, utils_1.parseAccount)(isDeployed ? client.account : signerClient.account);
    const request = {
        ...args,
        from: initiatorAccount.address,
    };
    let chainId;
    async function getChainId() {
        if (chainId)
            return chainId;
        if (chain)
            return chain.id;
        if (typeof args.chainId !== 'undefined')
            return args.chainId;
        const chainId_ = await (0, utils_1.getAction)(client, actions_1.getChainId, 'getChainId')({});
        chainId = chainId_;
        return chainId;
    }
    if (parameterNames.includes('chainId'))
        request.chainId = await getChainId();
    if (parameterNames.includes('nonce') &&
        typeof nonce === 'undefined' &&
        initiatorAccount) {
        request.nonce = await (0, utils_1.getAction)(publicClient, actions_1.getTransactionCount, 'getTransactionCount')({
            address: initiatorAccount.address,
            blockTag: 'pending',
        });
    }
    let gasFromFeeEstimation;
    if (parameterNames.includes('fees')) {
        if (typeof request.maxFeePerGas === 'undefined' ||
            typeof request.maxPriorityFeePerGas === 'undefined') {
            let maxFeePerGas;
            let maxPriorityFeePerGas;
            if (request.to === constants_js_1.CONTRACT_DEPLOYER_ADDRESS) {
                maxFeePerGas = 25000000n;
                maxPriorityFeePerGas = 0n;
            }
            else {
                const estimateFeeRequest = {
                    account: initiatorAccount,
                    to: request.to,
                    value: request.value,
                    data: request.data,
                    gas: request.gas,
                    nonce: request.nonce,
                    chainId: request.chainId,
                    authorizationList: [],
                };
                const feeEstimation = await (0, zksync_1.estimateFee)(publicClient, estimateFeeRequest);
                maxFeePerGas = feeEstimation.maxFeePerGas;
                maxPriorityFeePerGas = feeEstimation.maxPriorityFeePerGas;
                gasFromFeeEstimation = feeEstimation.gasLimit;
            }
            if (typeof args.maxPriorityFeePerGas === 'undefined' &&
                args.maxFeePerGas &&
                args.maxFeePerGas < maxPriorityFeePerGas)
                throw new MaxFeePerGasTooLowError({
                    maxPriorityFeePerGas,
                });
            request.maxPriorityFeePerGas = maxPriorityFeePerGas;
            request.maxFeePerGas = maxFeePerGas;
            if (typeof gas === 'undefined') {
                request.gas = gasFromFeeEstimation;
            }
        }
    }
    if (parameterNames.includes('gas') &&
        typeof gas === 'undefined' &&
        gasFromFeeEstimation === undefined)
        request.gas = await (0, utils_1.getAction)(client, actions_1.estimateGas, 'estimateGas')({
            ...request,
            account: initiatorAccount
                ? { address: initiatorAccount.address, type: 'json-rpc' }
                : undefined,
        });
    (0, utils_1.assertRequest)(request);
    delete request.parameters;
    delete request.isInitialTransaction;
    return request;
}
//# sourceMappingURL=prepareTransaction.js.map