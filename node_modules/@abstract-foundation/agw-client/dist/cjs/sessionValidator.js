"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.SessionKeyPolicyStatus = void 0;
exports.assertSessionKeyPolicies = assertSessionKeyPolicies;
const viem_1 = require("viem");
const chains_1 = require("viem/chains");
const utils_1 = require("viem/utils");
const SessionKeyPolicyRegistry_js_1 = require("./abis/SessionKeyPolicyRegistry.js");
const SessionKeyValidator_js_1 = require("./abis/SessionKeyValidator.js");
const constants_js_1 = require("./constants.js");
const constants_js_2 = require("./exports/constants.js");
const sessions_js_1 = require("./sessions.js");
const restrictedSelectors = new Set([
    (0, viem_1.toFunctionSelector)('function setApprovalForAll(address, bool)'),
    (0, viem_1.toFunctionSelector)('function approve(address, uint256)'),
    (0, viem_1.toFunctionSelector)('function transfer(address, uint256)'),
]);
var SessionKeyPolicyStatus;
(function (SessionKeyPolicyStatus) {
    SessionKeyPolicyStatus[SessionKeyPolicyStatus["Unset"] = 0] = "Unset";
    SessionKeyPolicyStatus[SessionKeyPolicyStatus["Allowed"] = 1] = "Allowed";
    SessionKeyPolicyStatus[SessionKeyPolicyStatus["Denied"] = 2] = "Denied";
})(SessionKeyPolicyStatus || (exports.SessionKeyPolicyStatus = SessionKeyPolicyStatus = {}));
async function assertSessionKeyPolicies(client, chainId, account, transaction) {
    if (chainId !== chains_1.abstract.id) {
        return;
    }
    const session = getSessionFromTransaction(account, transaction);
    if (!session) {
        return;
    }
    const callPolicies = session.callPolicies;
    const transferPolicies = session.transferPolicies;
    const checks = [];
    for (const callPolicy of callPolicies) {
        if (restrictedSelectors.has(callPolicy.selector)) {
            const destinationConstraints = callPolicy.constraints.filter((c) => c.index === 0n && c.condition === sessions_js_1.ConstraintCondition.Equal);
            if (destinationConstraints.length === 0) {
                throw new viem_1.BaseError(`Unconstrained token approval/transfer destination in call policy. Selector: ${callPolicy.selector}; Target: ${callPolicy.target}`);
            }
            for (const constraint of destinationConstraints) {
                const [target] = (0, utils_1.decodeAbiParameters)([
                    {
                        type: 'address',
                    },
                ], constraint.refValue);
                checks.push({
                    target,
                    check: {
                        address: constants_js_1.SESSION_KEY_POLICY_REGISTRY_ADDRESS,
                        abi: SessionKeyPolicyRegistry_js_1.SessionKeyPolicyRegistryAbi,
                        functionName: 'getApprovalTargetStatus',
                        args: [
                            callPolicy.target,
                            target,
                        ],
                    },
                });
            }
        }
        else {
            checks.push({
                target: callPolicy.target,
                check: {
                    address: constants_js_1.SESSION_KEY_POLICY_REGISTRY_ADDRESS,
                    abi: SessionKeyPolicyRegistry_js_1.SessionKeyPolicyRegistryAbi,
                    functionName: 'getCallPolicyStatus',
                    args: [callPolicy.target, callPolicy.selector],
                },
            });
        }
    }
    for (const transferPolicy of transferPolicies) {
        checks.push({
            target: transferPolicy.target,
            check: {
                address: constants_js_1.SESSION_KEY_POLICY_REGISTRY_ADDRESS,
                abi: SessionKeyPolicyRegistry_js_1.SessionKeyPolicyRegistryAbi,
                functionName: 'getTransferPolicyStatus',
                args: [transferPolicy.target],
            },
        });
    }
    const results = await client.multicall({
        contracts: checks.map((c) => c.check),
        allowFailure: false,
    });
    for (let i = 0; i < checks.length; i++) {
        const result = results[i];
        const check = checks[i];
        if (Number(result) !== SessionKeyPolicyStatus.Allowed) {
            throw new viem_1.BaseError(`Session key policy violation. Target: ${check?.target}; Status: ${SessionKeyPolicyStatus[Number(result)]}`);
        }
    }
}
function getSessionFromTransaction(account, transaction) {
    if (transaction.to === constants_js_1.SESSION_KEY_VALIDATOR_ADDRESS &&
        transaction.data?.substring(0, 10) === '0x5a0694d2') {
        const sessionSpec = (0, utils_1.decodeFunctionData)({
            abi: SessionKeyValidator_js_1.SessionKeyValidatorAbi,
            data: transaction.data,
        });
        if (sessionSpec.functionName === 'createSession') {
            return sessionSpec.args[0];
        }
    }
    if (transaction.to === account?.address &&
        transaction.data?.substring(0, 10) === '0xd3bdf4b5') {
        const moduleAndData = (0, utils_1.decodeFunctionData)({
            abi: constants_js_2.AGWAccountAbi,
            data: transaction.data,
        });
        if (moduleAndData.functionName === 'addModule' &&
            moduleAndData.args[0]
                .toLowerCase()
                .startsWith(constants_js_1.SESSION_KEY_VALIDATOR_ADDRESS.toLowerCase())) {
            const sessionData = moduleAndData.args[0].substring(42);
            return (0, utils_1.decodeAbiParameters)([(0, sessions_js_1.getSessionSpec)()], `0x${sessionData}`)[0];
        }
    }
    return undefined;
}
//# sourceMappingURL=sessionValidator.js.map