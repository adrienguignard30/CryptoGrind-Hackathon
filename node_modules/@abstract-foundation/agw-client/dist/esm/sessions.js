import { encodeAbiParameters, getAbiItem, getAddress, keccak256, } from 'viem';
import { SessionKeyValidatorAbi } from './abis/SessionKeyValidator.js';
export var LimitType;
(function (LimitType) {
    LimitType[LimitType["Unlimited"] = 0] = "Unlimited";
    LimitType[LimitType["Lifetime"] = 1] = "Lifetime";
    LimitType[LimitType["Allowance"] = 2] = "Allowance";
})(LimitType || (LimitType = {}));
export const LimitUnlimited = {
    limitType: LimitType.Unlimited,
    limit: 0n,
    period: 0n,
};
export const LimitZero = {
    limitType: LimitType.Lifetime,
    limit: 0n,
    period: 0n,
};
/**
 * Common logic operators to used combine multiple constraints
 */
export var ConstraintCondition;
(function (ConstraintCondition) {
    ConstraintCondition[ConstraintCondition["Unconstrained"] = 0] = "Unconstrained";
    ConstraintCondition[ConstraintCondition["Equal"] = 1] = "Equal";
    ConstraintCondition[ConstraintCondition["Greater"] = 2] = "Greater";
    ConstraintCondition[ConstraintCondition["Less"] = 3] = "Less";
    ConstraintCondition[ConstraintCondition["GreaterEqual"] = 4] = "GreaterEqual";
    ConstraintCondition[ConstraintCondition["LessEqual"] = 5] = "LessEqual";
    ConstraintCondition[ConstraintCondition["NotEqual"] = 6] = "NotEqual";
})(ConstraintCondition || (ConstraintCondition = {}));
export var SessionStatus;
(function (SessionStatus) {
    SessionStatus[SessionStatus["NotInitialized"] = 0] = "NotInitialized";
    SessionStatus[SessionStatus["Active"] = 1] = "Active";
    SessionStatus[SessionStatus["Closed"] = 2] = "Closed";
    SessionStatus[SessionStatus["Expired"] = 3] = "Expired";
})(SessionStatus || (SessionStatus = {}));
export function getSessionSpec() {
    return getAbiItem({
        abi: SessionKeyValidatorAbi,
        name: 'createSession',
    }).inputs[0];
}
export function encodeSession(sessionConfig) {
    return encodeAbiParameters([getSessionSpec()], [sessionConfig]);
}
export function encodeSessionWithPeriodIds(sessionConfig, periods) {
    return encodeAbiParameters([getSessionSpec(), { type: 'uint64[]' }], [sessionConfig, periods]);
}
export const getPeriodIdsForTransaction = (args) => {
    const timestamp = args.timestamp || BigInt(Math.floor(Date.now() / 1000));
    const target = getAddress(args.target);
    const getId = (limit) => {
        if (limit.limitType === LimitType.Allowance) {
            return timestamp / limit.period;
        }
        return 0n;
    };
    const findTransferPolicy = () => {
        return args.sessionConfig.transferPolicies.find((policy) => policy.target.toLowerCase() === target.toLowerCase());
    };
    const findCallPolicy = () => {
        return args.sessionConfig.callPolicies.find((policy) => policy.target.toLowerCase() === target.toLowerCase() &&
            policy.selector == args.selector);
    };
    const isContractCall = !!args.selector && args.selector.length >= 10;
    const policy = isContractCall
        ? findCallPolicy()
        : findTransferPolicy();
    if (!policy)
        throw new Error('Transaction does not fit any policy');
    const periodIds = [
        getId(args.sessionConfig.feeLimit),
        getId(policy.valueLimit),
        ...(isContractCall
            ? policy.constraints.map((constraint) => getId(constraint.limit))
            : []),
    ];
    return periodIds;
};
export function getSessionHash(sessionConfig) {
    return keccak256(encodeSession(sessionConfig));
}
//# sourceMappingURL=sessions.js.map