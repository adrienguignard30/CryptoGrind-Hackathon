import { checksumAddress, getAddress, InvalidAddressError, isAddress, } from 'viem';
import { readContract } from 'viem/actions';
import { getAction, parseAccount } from 'viem/utils';
import {} from 'viem/zksync';
import { ExclusiveDelegateResolverAbi } from '../abis/ExclusiveDelegateResolver.js';
import { AGW_LINK_DELEGATION_RIGHTS, CANONICAL_EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS, } from '../constants.js';
import { AccountNotFoundError } from '../errors/account.js';
export async function getLinkedAccounts(client, parameters) {
    const { agwAddress } = parameters;
    if (!isAddress(agwAddress, { strict: false })) {
        throw new InvalidAddressError({ address: agwAddress });
    }
    const checksummedAddress = getAddress(agwAddress);
    const result = await getAction(client, readContract, 'readContract')({
        abi: ExclusiveDelegateResolverAbi,
        address: CANONICAL_EXCLUSIVE_DELEGATE_RESOLVER_ADDRESS,
        functionName: 'delegatedWalletsByRights',
        args: [checksummedAddress, AGW_LINK_DELEGATION_RIGHTS],
    });
    return {
        linkedAccounts: [...result],
    };
}
export async function isLinkedAccount(client, parameters) {
    const { address } = parameters;
    if (!client.account) {
        throw new AccountNotFoundError({
            docsPath: '/docs/contract/readContract',
        });
    }
    const clientAccount = parseAccount(client.account);
    const { linkedAccounts } = await getLinkedAccounts(client, {
        agwAddress: clientAccount.address,
    });
    return linkedAccounts.includes(checksumAddress(address));
}
//# sourceMappingURL=getLinkedAccounts.js.map