import { BaseError, encodeFunctionData, formatGwei, keccak256, toBytes, } from 'viem';
import {} from 'viem/accounts';
import { estimateGas, getChainId as getChainId_, getTransactionCount, } from 'viem/actions';
import { assertRequest, getAction, parseAccount, } from 'viem/utils';
import { estimateFee, } from 'viem/zksync';
import { CONTRACT_DEPLOYER_ADDRESS, EOA_VALIDATOR_ADDRESS, SMART_ACCOUNT_FACTORY_ADDRESS, } from '../constants.js';
import { AccountFactoryAbi } from '../exports/constants.js';
import { isSmartAccountDeployed } from '../utils.js';
import { getInitializerCalldata } from '../utils.js';
export const defaultParameters = [
    'blobVersionedHashes',
    'chainId',
    'fees',
    'gas',
    'nonce',
    'type',
];
export class MaxFeePerGasTooLowError extends BaseError {
    constructor({ maxPriorityFeePerGas }) {
        super(`\`maxFeePerGas\` cannot be less than the \`maxPriorityFeePerGas\` (${formatGwei(maxPriorityFeePerGas)} gwei).`, { name: 'MaxFeePerGasTooLowError' });
    }
}
/**
 * Prepares a transaction request for signing.
 *
 * - Docs: https://viem.sh/docs/actions/wallet/prepareTransactionRequest
 *
 * @param args - {@link PrepareTransactionRequestParameters}
 * @returns The transaction request. {@link PrepareTransactionRequestReturnType}
 *
 * @example
 * import { createWalletClient, custom } from 'viem'
 * import { mainnet } from 'viem/chains'
 * import { prepareTransactionRequest } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const request = await prepareTransactionRequest(client, {
 *   account: '0xA0Cf798816D4b9b9866b5330EEa46a18382f251e',
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 *
 * @example
 * // Account Hoisting
 * import { createWalletClient, http } from 'viem'
 * import { privateKeyToAccount } from 'viem/accounts'
 * import { mainnet } from 'viem/chains'
 * import { prepareTransactionRequest } from 'viem/actions'
 *
 * const client = createWalletClient({
 *   account: privateKeyToAccount('0xâ€¦'),
 *   chain: mainnet,
 *   transport: custom(window.ethereum),
 * })
 * const request = await prepareTransactionRequest(client, {
 *   to: '0x0000000000000000000000000000000000000000',
 *   value: 1n,
 * })
 */
export async function prepareTransactionRequest(client, signerClient, publicClient, args) {
    const { chain, gas, nonce, parameters: parameterNames = defaultParameters, } = args;
    const isDeployed = await isSmartAccountDeployed(publicClient, client.account.address);
    if (!isDeployed) {
        const initialCall = {
            target: args.to,
            allowFailure: false,
            value: args.value ?? 0,
            callData: args.data ?? '0x',
        };
        // Create calldata for initializing the proxy account
        const initializerCallData = getInitializerCalldata(signerClient.account.address, EOA_VALIDATOR_ADDRESS, initialCall);
        const addressBytes = toBytes(signerClient.account.address);
        const salt = keccak256(addressBytes);
        const deploymentCalldata = encodeFunctionData({
            abi: AccountFactoryAbi,
            functionName: 'deployAccount',
            args: [salt, initializerCallData],
        });
        // Override transaction fields
        args.to = SMART_ACCOUNT_FACTORY_ADDRESS;
        args.data = deploymentCalldata;
    }
    const initiatorAccount = parseAccount(isDeployed ? client.account : signerClient.account);
    const request = {
        ...args,
        from: initiatorAccount.address,
    };
    let chainId;
    async function getChainId() {
        if (chainId)
            return chainId;
        if (chain)
            return chain.id;
        if (typeof args.chainId !== 'undefined')
            return args.chainId;
        const chainId_ = await getAction(client, getChainId_, 'getChainId')({});
        chainId = chainId_;
        return chainId;
    }
    if (parameterNames.includes('chainId'))
        request.chainId = await getChainId();
    if (parameterNames.includes('nonce') &&
        typeof nonce === 'undefined' &&
        initiatorAccount) {
        request.nonce = await getAction(publicClient, // The public client is more reliable for fetching the latest nonce
        getTransactionCount, 'getTransactionCount')({
            address: initiatorAccount.address,
            blockTag: 'pending',
        });
    }
    let gasFromFeeEstimation;
    if (parameterNames.includes('fees')) {
        if (typeof request.maxFeePerGas === 'undefined' ||
            typeof request.maxPriorityFeePerGas === 'undefined') {
            let maxFeePerGas;
            let maxPriorityFeePerGas;
            // Skip fee estimation for contract deployments
            if (request.to === CONTRACT_DEPLOYER_ADDRESS) {
                maxFeePerGas = 25000000n;
                maxPriorityFeePerGas = 0n;
            }
            else {
                const estimateFeeRequest = {
                    account: initiatorAccount,
                    to: request.to,
                    value: request.value,
                    data: request.data,
                    gas: request.gas,
                    nonce: request.nonce,
                    chainId: request.chainId,
                    authorizationList: [],
                };
                const feeEstimation = await estimateFee(publicClient, estimateFeeRequest);
                maxFeePerGas = feeEstimation.maxFeePerGas;
                maxPriorityFeePerGas = feeEstimation.maxPriorityFeePerGas;
                gasFromFeeEstimation = feeEstimation.gasLimit;
            }
            if (typeof args.maxPriorityFeePerGas === 'undefined' &&
                args.maxFeePerGas &&
                args.maxFeePerGas < maxPriorityFeePerGas)
                throw new MaxFeePerGasTooLowError({
                    maxPriorityFeePerGas,
                });
            request.maxPriorityFeePerGas = maxPriorityFeePerGas;
            request.maxFeePerGas = maxFeePerGas;
            // set gas to gasFromFeeEstimation if gas is not already set
            if (typeof gas === 'undefined') {
                request.gas = gasFromFeeEstimation;
            }
        }
    }
    if (parameterNames.includes('gas') &&
        typeof gas === 'undefined' &&
        gasFromFeeEstimation === undefined // if gas was set by fee estimation, don't estimate again
    )
        request.gas = await getAction(client, estimateGas, 'estimateGas')({
            ...request,
            account: initiatorAccount
                ? { address: initiatorAccount.address, type: 'json-rpc' }
                : undefined,
        });
    assertRequest(request);
    delete request.parameters;
    delete request.isInitialTransaction;
    return request;
}
//# sourceMappingURL=prepareTransaction.js.map