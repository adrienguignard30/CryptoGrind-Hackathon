import { walletActions, } from 'viem';
import { parseAccount } from 'viem/accounts';
import { getChainId } from 'viem/actions';
import {} from 'viem/zksync';
import {} from './abstractClient.js';
import { createSession, } from './actions/createSession.js';
import { deployContract } from './actions/deployContract.js';
import { getLinkedAccounts, } from './actions/getLinkedAccounts.js';
import { getLinkedAgw, isLinkedAccount, } from './actions/getLinkedAgw.js';
import { getSessionStatus } from './actions/getSessionStatus.js';
import { linkToAgw, } from './actions/linkToAgw.js';
import { prepareTransactionRequest, } from './actions/prepareTransaction.js';
import { revokeSessions, } from './actions/revokeSessions.js';
import { sendTransaction } from './actions/sendTransaction.js';
import { sendTransactionBatch } from './actions/sendTransactionBatch.js';
import { sendTransactionForSession } from './actions/sendTransactionForSession.js';
import { signMessage } from './actions/signMessage.js';
import { signTransaction } from './actions/signTransaction.js';
import { signTransactionForSession } from './actions/signTransactionForSession.js';
import { signTypedData, signTypedDataForSession, } from './actions/signTypedData.js';
import { writeContract } from './actions/writeContract.js';
import { writeContractForSession } from './actions/writeContractForSession.js';
import { EOA_VALIDATOR_ADDRESS } from './constants.js';
import { toSessionClient } from './sessionClient.js';
export function sessionWalletActions(signerClient, publicClient, session, paymasterHandler) {
    return (client) => ({
        sendTransaction: (args) => sendTransactionForSession(client, signerClient, publicClient, args, session, paymasterHandler),
        writeContract: (args) => writeContractForSession(client, signerClient, publicClient, args, session, paymasterHandler),
        signTransaction: (args) => signTransactionForSession(client, signerClient, publicClient, args, session, paymasterHandler),
        signTypedData: (args) => signTypedDataForSession(client, signerClient, publicClient, args, session, paymasterHandler),
        getSessionStatus: () => getSessionStatus(publicClient, parseAccount(client.account).address, session),
    });
}
export function globalWalletActions(signerClient, publicClient, isPrivyCrossApp = false, customPaymasterHandler) {
    return (client) => ({
        getChainId: () => getChainId(client),
        getLinkedAccounts: () => getLinkedAccounts(client, {
            agwAddress: parseAccount(client.account).address,
        }),
        isLinkedAccount: (args) => isLinkedAccount(client, args),
        createSession: (args) => createSession(client, publicClient, args),
        revokeSessions: (args) => revokeSessions(client, args),
        prepareAbstractTransactionRequest: (args) => prepareTransactionRequest(client, signerClient, publicClient, args),
        sendTransaction: (args) => sendTransaction(client, signerClient, publicClient, args, isPrivyCrossApp, customPaymasterHandler),
        sendTransactionBatch: (args) => sendTransactionBatch(client, signerClient, publicClient, args, isPrivyCrossApp, customPaymasterHandler),
        signMessage: (args) => signMessage(client, signerClient, args, isPrivyCrossApp),
        signTransaction: (args) => signTransaction(client, signerClient, publicClient, args, EOA_VALIDATOR_ADDRESS, {}, customPaymasterHandler, isPrivyCrossApp),
        signTypedData: (args) => signTypedData(client, signerClient, publicClient, args, isPrivyCrossApp),
        deployContract: (args) => deployContract(client, signerClient, publicClient, args, isPrivyCrossApp),
        writeContract: (args) => writeContract(Object.assign(client, {
            sendTransaction: (args) => sendTransaction(client, signerClient, publicClient, args, isPrivyCrossApp, customPaymasterHandler),
        }), signerClient, publicClient, args, isPrivyCrossApp),
        toSessionClient: (signer, session) => toSessionClient({
            client: client,
            signer,
            session: session,
            paymasterHandler: customPaymasterHandler,
        }),
        getSessionStatus: (sessionHashOrConfig) => getSessionStatus(publicClient, parseAccount(client.account).address, sessionHashOrConfig),
    });
}
export function linkableWalletActions() {
    return (client) => ({
        ...walletActions(client),
        linkToAgw: (args) => linkToAgw(client, args),
        getLinkedAgw: () => getLinkedAgw(client, {}),
    });
}
export function linkablePublicActions() {
    return (client) => ({
        getLinkedAgw: (args) => getLinkedAgw(client, args),
        getLinkedAccounts: (args) => getLinkedAccounts(client, args),
    });
}
//# sourceMappingURL=walletActions.js.map