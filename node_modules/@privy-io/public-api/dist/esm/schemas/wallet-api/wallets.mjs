import{z as t}from"zod";import{InvalidInputError as e,PrivyErrorCode as i}from"@privy-io/api-base";import{Pagination as a}from"../api.mjs";import{SolanaWalletAddress as o,WalletAddress as r}from"../core.mjs";import{PrivateKeyExportInput as n}from"./export.mjs";import"bs58";import"libphonenumber-js/max";import"viem";const s=t.string().regex(/^[-a-z0-9]{3,8}:[-_a-zA-Z0-9]{1,32}$/,"Chain ID must be a valid CAIP-2 chain ID, e.g. 'eip155:1'");let l=t.object({address:o.optional(),chain_type:t.literal("solana").optional()}),d=t.object({address:r.optional(),chain_type:t.literal("ethereum").optional()});const c=t.enum(["root","manager","delegated-actions"]).nullable(),g=t.object({method:t.literal("signTransaction"),params:t.object({transaction:t.string(),encoding:t.literal("base64")})}).merge(l),h=t.object({method:t.literal("signAndSendTransaction"),caip2:s,params:t.object({transaction:t.string(),encoding:t.literal("base64")})}).merge(l),m=t.object({method:t.literal("signMessage"),params:t.object({message:t.string(),encoding:t.literal("base64")})}).merge(l),p=t.string().startsWith("0x").refine((t=>!t.includes(".")),"Invalid hex string: must start with '0x' and not contain decimal points"),_=t.custom((t=>"string"==typeof t&&t.startsWith("0x")));let b=t.number().int().nonnegative().safe({message:'Please use hex string prefixed with "0x" to represent large numbers (e.g. "0xDE0B6B3A7640000").'});const u=t.union([p,b],{invalid_type_error:"Invalid quantity: must be either a hex string starting with '0x' or a non-negative integer."}),j=t.object({from:r.optional(),to:r.optional(),chain_id:u.optional(),nonce:u.optional(),data:p.optional(),value:u.optional(),type:t.union([t.literal(0),t.literal(1),t.literal(2)]).optional(),gas_limit:u.optional(),gas_price:u.optional(),max_fee_per_gas:u.optional(),max_priority_fee_per_gas:u.optional()}),y=t.object({method:t.literal("eth_signTransaction"),params:t.object({transaction:j})}).merge(d),z=t.object({method:t.literal("eth_sendTransaction"),caip2:s,params:t.object({transaction:j})}).merge(d),v=t.object({message:t.string(),encoding:t.union([t.literal("utf-8"),t.literal("hex")])}),f=t.object({method:t.literal("personal_sign"),params:v}).merge(d),x=t.object({method:t.literal("secp256k1_sign"),params:t.object({hash:_})}).merge(d),k=t.record(t.string(),t.any()),I=t.object({name:t.string(),version:t.string(),chainId:t.number(),verifyingContract:t.string()}).merge(t.object({}).catchall(t.any())),T=t.union([I,k]),w=t.record(t.array(t.object({name:t.string(),type:t.string()}))),A=t.object({method:t.literal("eth_signTypedData_v4"),params:t.object({typed_data:t.object({domain:T,types:w,message:t.record(t.string(),t.any()),primary_type:t.string()})})}).merge(d),D=t.object({address:t.string(),method:t.literal("exportPrivateKey"),params:n}),P=t.discriminatedUnion("method",[y,z,f,A,x]),U=t.discriminatedUnion("method",[g,h,m]),W=t.union([P,U,D]),C=t.object({method:t.literal("signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("base64")})}),K=t.object({method:t.literal("signAndSendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:s}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),M=t.object({method:t.literal("signMessage"),data:t.object({signature:t.string(),encoding:t.literal("base64")})}),O=t.object({method:t.literal("eth_signTransaction"),data:t.object({signed_transaction:t.string(),encoding:t.literal("rlp")})}),S=t.object({method:t.literal("eth_sendTransaction"),data:t.object({transaction_id:t.string().optional(),hash:t.string(),caip2:s}).optional(),error:t.object({code:t.string(),message:t.string()}).optional()}),q=t.object({method:t.literal("personal_sign"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),B=t.object({method:t.literal("secp256k1_sign"),data:t.object({signature:p,encoding:t.literal("hex")})}),L=t.object({method:t.literal("eth_signTypedData_v4"),data:t.object({signature:t.string(),encoding:t.literal("hex")})}),N=t.object({method:t.literal("exportPrivateKey"),data:n}),V=t.discriminatedUnion("method",[C,K,M,O,S,q,B,L,N]),E=t.object({display_name:t.string().optional(),public_key:t.string(),role:c.optional()});let R=t.union([t.literal("solana"),t.literal("ethereum")]);const Z=t.object({id:t.string(),address:t.string(),created_at:t.number(),chain_type:R,policy_ids:t.array(t.string()),authorization_threshold:t.number().optional(),additional_signers:t.array(t.object({signer_id:t.string().cuid2()})),owner_id:t.string().cuid2().nullable()}),$=t.string().cuid2(),F=t.string(),G=t.object({public_key:F}).strict(),H={owner:G.nullable().optional(),owner_id:$.nullable().optional()},J=t.array(t.object({signer_id:$}).strict()),Q=t.object({chain_type:R,policy_ids:t.array(t.string()).max(1).optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:J.optional(),...H}),X=Q.refine((t=>{let e=void 0!==t.authorization_key_ids||void 0!==t.authorization_threshold,i=void 0!==t.additional_signers;return!e||!i}),"Please provide either additional_signers or authorization_key_ids, not both").refine((t=>void 0===t.authorization_threshold||t.authorization_threshold>=1&&t.authorization_key_ids&&t.authorization_threshold<=t.authorization_key_ids.length),{message:"If specified, authorization_threshold must be an integer between 1 and the length of authorization_key_ids."}).refine((t=>!t.owner||!t.owner_id),{message:"Only one of owner or owner_id can be provided."}).catch((t=>{throw new e(t.error.message,i.INVALID_DATA)})),Y=t.object({id:t.string(),chain_type:R,address:t.string(),authorization_threshold:t.number().optional()}),tt=t.object({wallet_id:t.string({required_error:"Wallet ID must be provided",invalid_type_error:"Wallet ID is not a valid string"}).min(1)}).catch((({error:t})=>{throw new e(t.message,i.INVALID_DATA)})),et=t.object({id:t.string()}),it=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),role:c,created_at:t.number()}),at=t.object({id:t.string(),display_name:t.string().nullable(),public_key:t.string(),created_at:t.number()}),ot=a.extend({chain_type:R.optional()}).strict(),rt=t.object({policy_ids:t.array(t.string()).max(1,"Only one policy ID can be set").optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:J.optional()}).strict().superRefine(((t,e)=>{Object.values(t).every((t=>null==t))&&e.addIssue({code:"custom",message:"At least one field must be provided"}),void 0!==t.authorization_threshold&&0!==t.authorization_threshold&&(t.authorization_threshold<0&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}),void 0===t.authorization_key_ids&&e.addIssue({code:"custom",path:["authorization_key_ids"],message:"An array of `authorization_key_ids` must be provided for a non-zero `authorization_threshold`."}),t.authorization_key_ids&&t.authorization_threshold>t.authorization_key_ids.length&&e.addIssue({code:"custom",path:["authorization_threshold"],message:"`authorization_threshold` must be non-negative if specified."}))})),nt=t.object({method:t.literal("signTransaction"),params:t.object({transaction:t.string(),encoding:t.literal("base64")}).strict()}).merge(l).strict(),st=t.object({method:t.literal("signAndSendTransaction"),caip2:s,params:t.object({transaction:t.string(),encoding:t.literal("base64")}).strict()}).merge(l).strict(),lt=t.object({method:t.literal("signMessage"),params:t.object({message:t.string(),encoding:t.literal("base64")}).strict()}).merge(l).strict(),dt=t.object({from:r.optional(),to:r.optional(),chain_id:u.optional(),nonce:u.optional(),data:p.optional(),value:u.optional(),type:t.union([t.literal(0),t.literal(1),t.literal(2)]).optional(),gas_limit:u.optional(),gas_price:u.optional(),max_fee_per_gas:u.optional(),max_priority_fee_per_gas:u.optional()}).strict(),ct=t.object({method:t.literal("eth_signTransaction"),params:t.object({transaction:dt}).strict()}).merge(d).strict(),gt=t.object({method:t.literal("eth_sendTransaction"),caip2:s,params:t.object({transaction:dt}).strict()}).merge(d).strict(),ht=t.object({message:t.string(),encoding:t.union([t.literal("utf-8"),t.literal("hex")])}).strict(),mt=t.object({method:t.literal("personal_sign"),params:ht}).merge(d).strict(),pt=t.object({method:t.literal("secp256k1_sign"),params:t.object({hash:_}).strict()}).merge(d).strict(),_t=t.object({method:t.literal("eth_signTypedData_v4"),params:t.object({typed_data:t.object({domain:T,types:w,message:t.record(t.string(),t.any()),primary_type:t.string()}).strict()}).strict()}).merge(d).strict(),bt=t.object({address:t.string(),method:t.literal("exportPrivateKey"),params:n}).strict(),ut=t.discriminatedUnion("method",[ct,gt,mt,_t,pt]),jt=t.discriminatedUnion("method",[nt,st,lt]),yt=t.union([ut,jt,bt]),zt=t.object({chain_type:R,policy_ids:t.array(t.string()).max(1).optional(),authorization_key_ids:t.array(t.string()).optional(),authorization_threshold:t.number().optional(),additional_signers:t.array(t.object({signer_id:t.string().cuid2()}).strict()).optional(),...H}).strict();export{J as AdditionalSignerInput,it as AuthorizationKeyDashboardResponse,at as AuthorizationKeyResponse,c as AuthorizationKeyRole,Q as BaseWalletApiCreateInput,s as CAIP2,I as CurrentTypedDataDomainInputParams,_ as Hash,p as Hex,$ as KeyQuorumId,k as LegacyTypedDataDomainInputParams,G as OwnerInput,H as OwnerInputFields,F as P256PublicKey,u as Quantity,T as TypedDataDomainInputParams,w as TypedDataTypesInputParams,j as UnsignedEthereumTransaction,dt as UnsignedEthereumTransactionStrict,X as WalletApiCreateInput,Y as WalletApiCreateResponse,zt as WalletApiCreateStrictInput,f as WalletApiEthereumPersonalSignRpcInput,v as WalletApiEthereumPersonalSignRpcInputParams,q as WalletApiEthereumPersonalSignRpcResponse,mt as WalletApiEthereumPersonalSignRpcStrictInput,ht as WalletApiEthereumPersonalSignRpcStrictInputParams,P as WalletApiEthereumRpcInput,ut as WalletApiEthereumRpcStrictInput,x as WalletApiEthereumSecp256k1SignRpcInput,B as WalletApiEthereumSecp256k1SignRpcResponse,pt as WalletApiEthereumSecp256k1SignRpcStrictInput,z as WalletApiEthereumSendTransactionRpcInput,S as WalletApiEthereumSendTransactionRpcResponse,gt as WalletApiEthereumSendTransactionRpcStrictInput,y as WalletApiEthereumSignTransactionRpcInput,O as WalletApiEthereumSignTransactionRpcResponse,ct as WalletApiEthereumSignTransactionRpcStrictInput,A as WalletApiEthereumSignTypedDataRpcInput,L as WalletApiEthereumSignTypedDataRpcResponse,_t as WalletApiEthereumSignTypedDataRpcStrictInput,D as WalletApiExportPrivateKeyRpcInput,N as WalletApiExportPrivateKeyRpcResponse,bt as WalletApiExportPrivateKeyRpcStrictInput,E as WalletApiRegisterAuthorizationKeyInput,et as WalletApiRevokeAuthorizationKeyInput,W as WalletApiRpcInput,V as WalletApiRpcResponse,yt as WalletApiRpcStrictInput,U as WalletApiSolanaRpcInput,jt as WalletApiSolanaRpcStrictInput,h as WalletApiSolanaSignAndSendTransactionRpcInput,K as WalletApiSolanaSignAndSendTransactionRpcResponse,st as WalletApiSolanaSignAndSendTransactionRpcStrictInput,m as WalletApiSolanaSignMessageRpcInput,M as WalletApiSolanaSignMessageRpcResponse,lt as WalletApiSolanaSignMessageRpcStrictInput,g as WalletApiSolanaSignTransactionRpcInput,C as WalletApiSolanaSignTransactionRpcResponse,nt as WalletApiSolanaSignTransactionRpcStrictInput,tt as WalletIdFromPath,Z as WalletResponse,rt as WalletUpdateInput,ot as WalletsSearchInput};
