{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeEventLog = decodeEventLog;\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst size_js_1 = require(\"../data/size.js\");\nconst toEventSelector_js_1 = require(\"../hash/toEventSelector.js\");\nconst cursor_js_1 = require(\"../../errors/cursor.js\");\nconst decodeAbiParameters_js_1 = require(\"./decodeAbiParameters.js\");\nconst formatAbiItem_js_1 = require(\"./formatAbiItem.js\");\nconst docsPath = '/docs/contract/decodeEventLog';\nfunction decodeEventLog(parameters) {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics\n  } = parameters;\n  const strict = strict_ ?? true;\n  const [signature, ...argTopics] = topics;\n  if (!signature) throw new abi_js_1.AbiEventSignatureEmptyTopicsError({\n    docsPath\n  });\n  const abiItem = (() => {\n    if (abi.length === 1) return abi[0];\n    return abi.find(x => x.type === 'event' && signature === (0, toEventSelector_js_1.toEventSelector)((0, formatAbiItem_js_1.formatAbiItem)(x)));\n  })();\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event') throw new abi_js_1.AbiEventSignatureNotFoundError(signature, {\n    docsPath\n  });\n  const {\n    name,\n    inputs\n  } = abiItem;\n  const isUnnamed = inputs?.some(x => !('name' in x && x.name));\n  let args = isUnnamed ? [] : {};\n  const indexedInputs = inputs.filter(x => 'indexed' in x && x.indexed);\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i];\n    const topic = argTopics[i];\n    if (!topic) throw new abi_js_1.DecodeLogTopicsMismatch({\n      abiItem,\n      param: param\n    });\n    args[isUnnamed ? i : param.name || i] = decodeTopic({\n      param,\n      value: topic\n    });\n  }\n  const nonIndexedInputs = inputs.filter(x => !('indexed' in x && x.indexed));\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = (0, decodeAbiParameters_js_1.decodeAbiParameters)(nonIndexedInputs, data);\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData];else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name] = decodedData[i];\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (err instanceof abi_js_1.AbiDecodingDataSizeTooSmallError || err instanceof cursor_js_1.PositionOutOfBoundsError) throw new abi_js_1.DecodeLogDataMismatch({\n            abiItem,\n            data: data,\n            params: nonIndexedInputs,\n            size: (0, size_js_1.size)(data)\n          });\n          throw err;\n        }\n      }\n    } else if (strict) {\n      throw new abi_js_1.DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0\n      });\n    }\n  }\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined\n  };\n}\nfunction decodeTopic({\n  param,\n  value\n}) {\n  if (param.type === 'string' || param.type === 'bytes' || param.type === 'tuple' || param.type.match(/^(.*)\\[(\\d+)?\\]$/)) return value;\n  const decodedArg = (0, decodeAbiParameters_js_1.decodeAbiParameters)([param], value) || [];\n  return decodedArg[0];\n}","map":{"version":3,"names":["exports","decodeEventLog","abi_js_1","require","size_js_1","toEventSelector_js_1","cursor_js_1","decodeAbiParameters_js_1","formatAbiItem_js_1","docsPath","parameters","abi","data","strict","strict_","topics","signature","argTopics","AbiEventSignatureEmptyTopicsError","abiItem","length","find","x","type","toEventSelector","formatAbiItem","AbiEventSignatureNotFoundError","name","inputs","isUnnamed","some","args","indexedInputs","filter","indexed","i","param","topic","DecodeLogTopicsMismatch","decodeTopic","value","nonIndexedInputs","decodedData","decodeAbiParameters","err","AbiDecodingDataSizeTooSmallError","PositionOutOfBoundsError","DecodeLogDataMismatch","params","size","eventName","Object","values","undefined","match","decodedArg"],"sources":["C:\\Users\\Adrien\\Desktop\\CryptoGrind - Copie\\client\\node_modules\\viem\\utils\\abi\\decodeEventLog.ts"],"sourcesContent":["import type { Abi, AbiParameter } from 'abitype'\n\nimport {\n  AbiDecodingDataSizeTooSmallError,\n  type AbiDecodingDataSizeTooSmallErrorType,\n  AbiEventSignatureEmptyTopicsError,\n  type AbiEventSignatureEmptyTopicsErrorType,\n  AbiEventSignatureNotFoundError,\n  type AbiEventSignatureNotFoundErrorType,\n  DecodeLogDataMismatch,\n  type DecodeLogDataMismatchErrorType,\n  DecodeLogTopicsMismatch,\n  type DecodeLogTopicsMismatchErrorType,\n} from '../../errors/abi.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type {\n  ContractEventArgsFromTopics,\n  ContractEventName,\n  EventDefinition,\n} from '../../types/contract.js'\nimport type { Hex } from '../../types/misc.js'\nimport type {\n  IsNarrowable,\n  Prettify,\n  UnionEvaluate,\n} from '../../types/utils.js'\nimport { size } from '../data/size.js'\nimport {\n  type ToEventSelectorErrorType,\n  toEventSelector,\n} from '../hash/toEventSelector.js'\n\nimport { PositionOutOfBoundsError } from '../../errors/cursor.js'\nimport {\n  type DecodeAbiParametersErrorType,\n  decodeAbiParameters,\n} from './decodeAbiParameters.js'\nimport { type FormatAbiItemErrorType, formatAbiItem } from './formatAbiItem.js'\n\nexport type DecodeEventLogParameters<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n> = {\n  abi: abi\n  data?: data | undefined\n  eventName?: eventName | ContractEventName<abi> | undefined\n  strict?: strict | boolean | undefined\n  topics: [signature: Hex, ...args: topics] | []\n}\n\nexport type DecodeEventLogReturnType<\n  abi extends Abi | readonly unknown[] = Abi,\n  eventName extends ContractEventName<abi> | undefined = ContractEventName<abi>,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n  ///\n  allEventNames extends\n    ContractEventName<abi> = eventName extends ContractEventName<abi>\n    ? eventName\n    : ContractEventName<abi>,\n> = IsNarrowable<abi, Abi> extends true\n  ? {\n      [name in allEventNames]: Prettify<\n        {\n          eventName: name\n        } & UnionEvaluate<\n          ContractEventArgsFromTopics<abi, name, strict> extends infer allArgs\n            ? topics extends readonly []\n              ? data extends undefined\n                ? { args?: undefined }\n                : { args?: allArgs | undefined }\n              : { args: allArgs }\n            : never\n        >\n      >\n    }[allEventNames]\n  : {\n      eventName: eventName\n      args: readonly unknown[] | undefined\n    }\n\nexport type DecodeEventLogErrorType =\n  | AbiDecodingDataSizeTooSmallErrorType\n  | AbiEventSignatureEmptyTopicsErrorType\n  | AbiEventSignatureNotFoundErrorType\n  | DecodeAbiParametersErrorType\n  | DecodeLogTopicsMismatchErrorType\n  | DecodeLogDataMismatchErrorType\n  | FormatAbiItemErrorType\n  | ToEventSelectorErrorType\n  | ErrorType\n\nconst docsPath = '/docs/contract/decodeEventLog'\n\nexport function decodeEventLog<\n  const abi extends Abi | readonly unknown[],\n  eventName extends ContractEventName<abi> | undefined = undefined,\n  topics extends Hex[] = Hex[],\n  data extends Hex | undefined = undefined,\n  strict extends boolean = true,\n>(\n  parameters: DecodeEventLogParameters<abi, eventName, topics, data, strict>,\n): DecodeEventLogReturnType<abi, eventName, topics, data, strict> {\n  const {\n    abi,\n    data,\n    strict: strict_,\n    topics,\n  } = parameters as DecodeEventLogParameters\n\n  const strict = strict_ ?? true\n  const [signature, ...argTopics] = topics\n  if (!signature) throw new AbiEventSignatureEmptyTopicsError({ docsPath })\n\n  const abiItem = (() => {\n    if (abi.length === 1) return abi[0]\n    return abi.find(\n      (x) =>\n        x.type === 'event' &&\n        signature === toEventSelector(formatAbiItem(x) as EventDefinition),\n    )\n  })()\n\n  if (!(abiItem && 'name' in abiItem) || abiItem.type !== 'event')\n    throw new AbiEventSignatureNotFoundError(signature, { docsPath })\n\n  const { name, inputs } = abiItem\n  const isUnnamed = inputs?.some((x) => !('name' in x && x.name))\n\n  let args: any = isUnnamed ? [] : {}\n\n  // Decode topics (indexed args).\n  const indexedInputs = inputs.filter((x) => 'indexed' in x && x.indexed)\n  for (let i = 0; i < indexedInputs.length; i++) {\n    const param = indexedInputs[i]\n    const topic = argTopics[i]\n    if (!topic)\n      throw new DecodeLogTopicsMismatch({\n        abiItem,\n        param: param as AbiParameter & { indexed: boolean },\n      })\n    args[isUnnamed ? i : param.name || i] = decodeTopic({ param, value: topic })\n  }\n\n  // Decode data (non-indexed args).\n  const nonIndexedInputs = inputs.filter((x) => !('indexed' in x && x.indexed))\n  if (nonIndexedInputs.length > 0) {\n    if (data && data !== '0x') {\n      try {\n        const decodedData = decodeAbiParameters(nonIndexedInputs, data)\n        if (decodedData) {\n          if (isUnnamed) args = [...args, ...decodedData]\n          else {\n            for (let i = 0; i < nonIndexedInputs.length; i++) {\n              args[nonIndexedInputs[i].name!] = decodedData[i]\n            }\n          }\n        }\n      } catch (err) {\n        if (strict) {\n          if (\n            err instanceof AbiDecodingDataSizeTooSmallError ||\n            err instanceof PositionOutOfBoundsError\n          )\n            throw new DecodeLogDataMismatch({\n              abiItem,\n              data: data,\n              params: nonIndexedInputs,\n              size: size(data),\n            })\n          throw err\n        }\n      }\n    } else if (strict) {\n      throw new DecodeLogDataMismatch({\n        abiItem,\n        data: '0x',\n        params: nonIndexedInputs,\n        size: 0,\n      })\n    }\n  }\n\n  return {\n    eventName: name,\n    args: Object.values(args).length > 0 ? args : undefined,\n  } as unknown as DecodeEventLogReturnType<abi, eventName, topics, data, strict>\n}\n\nfunction decodeTopic({ param, value }: { param: AbiParameter; value: Hex }) {\n  if (\n    param.type === 'string' ||\n    param.type === 'bytes' ||\n    param.type === 'tuple' ||\n    param.type.match(/^(.*)\\[(\\d+)?\\]$/)\n  )\n    return value\n  const decodedArg = decodeAbiParameters([param], value) || []\n  return decodedArg[0]\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}