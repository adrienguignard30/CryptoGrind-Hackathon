{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isNegativeLE = void 0;\nexports.mod = mod;\nexports.pow = pow;\nexports.pow2 = pow2;\nexports.invert = invert;\nexports.tonelliShanks = tonelliShanks;\nexports.FpSqrt = FpSqrt;\nexports.validateField = validateField;\nexports.FpPow = FpPow;\nexports.FpInvertBatch = FpInvertBatch;\nexports.FpDiv = FpDiv;\nexports.FpLegendre = FpLegendre;\nexports.FpIsSquare = FpIsSquare;\nexports.nLength = nLength;\nexports.Field = Field;\nexports.FpSqrtOdd = FpSqrtOdd;\nexports.FpSqrtEven = FpSqrtEven;\nexports.hashToPrivateScalar = hashToPrivateScalar;\nexports.getFieldBytesLength = getFieldBytesLength;\nexports.getMinHashLength = getMinHashLength;\nexports.mapHashToField = mapHashToField;\n/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nconst utils_js_1 = require(\"./utils.js\");\n// prettier-ignore\nconst _0n = BigInt(0),\n  _1n = BigInt(1),\n  _2n = /* @__PURE__ */BigInt(2),\n  _3n = /* @__PURE__ */BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */BigInt(4),\n  _5n = /* @__PURE__ */BigInt(5),\n  _8n = /* @__PURE__ */BigInt(8);\n// prettier-ignore\nconst _9n = /* @__PURE__ */BigInt(9),\n  _16n = /* @__PURE__ */BigInt(16);\n// Calculates a modulo b\nfunction mod(a, b) {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nfunction pow(num, power, modulo) {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (modulo <= _0n) throw new Error('invalid modulus');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = res * num % modulo;\n    num = num * num % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nfunction pow2(x, power, modulo) {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nfunction invert(number, modulo) {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n,\n    y = _1n,\n    u = _1n,\n    v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nfunction tonelliShanks(P) {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) ≡ 1    if a is a square (mod p)\n  // (a | p) ≡ -1   if a is not a square (mod p)\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n  let Q, S, Z;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n  // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n    // Crash instead of infinity loop, we cannot reasonable count until P.\n    if (Z > 1000) throw new Error('Cannot find square root: likely non-prime P');\n  }\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast(Fp, n) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow(Fp, n) {\n    // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nfunction FpSqrt(P) {\n  // P ≡ 3 (mod 4)\n  // √n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4(Fp, n) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n  // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8(Fp, n) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n  // P ≡ 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n// Little-endian check for first LE bit (last BE bit);\nconst isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;\nexports.isNegativeLE = isNegativeLE;\n// prettier-ignore\nconst FIELD_FIELDS = ['create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr', 'eql', 'add', 'sub', 'mul', 'pow', 'div', 'addN', 'subN', 'mulN', 'sqrN'];\nfunction validateField(field) {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger'\n  };\n  const opts = FIELD_FIELDS.reduce((map, val) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return (0, utils_js_1.validateObject)(field, opts);\n}\n// Generic field functions\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nfunction FpPow(f, num, power) {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nfunction FpInvertBatch(f, nums) {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\nfunction FpDiv(f, lhs, rhs) {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n/**\n * Legendre symbol.\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nfunction FpLegendre(order) {\n  const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n  return (f, x) => f.pow(x, legendreConst);\n}\n// This function returns True whenever the value x is a square in the field F.\nfunction FpIsSquare(f) {\n  const legendre = FpLegendre(f.ORDER);\n  return x => {\n    const p = legendre(f, x);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n// CURVE.n lengths\nfunction nLength(n, nBitLength) {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return {\n    nBitLength: _nBitLength,\n    nByteLength\n  };\n}\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nfunction Field(ORDER, bitLen, isLE = false, redef = {}) {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  const {\n    nBitLength: BITS,\n    nByteLength: BYTES\n  } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP; // cached sqrtP\n  const f = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: (0, utils_js_1.bitMask)(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: num => mod(num, ORDER),\n    isValid: num => {\n      if (typeof num !== 'bigint') throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: num => num === _0n,\n    isOdd: num => (num & _1n) === _1n,\n    neg: num => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n    sqr: num => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n    // Same as above, but doesn't normalize\n    sqrN: num => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n    inv: num => invert(num, ORDER),\n    sqrt: redef.sqrt || (n => {\n      if (!sqrtP) sqrtP = FpSqrt(ORDER);\n      return sqrtP(f, n);\n    }),\n    invertBatch: lst => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => c ? b : a,\n    toBytes: num => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),\n    fromBytes: bytes => {\n      if (bytes.length !== BYTES) throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);\n    }\n  });\n  return Object.freeze(f);\n}\nfunction FpSqrtOdd(Fp, elm) {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\nfunction FpSqrtEven(Fp, elm) {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nfunction hashToPrivateScalar(hash, groupOrder, isLE = false) {\n  hash = (0, utils_js_1.ensureBytes)('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024) throw new Error('hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen);\n  const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nfunction getFieldBytesLength(fieldOrder) {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nfunction getMinHashLength(fieldOrder) {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nfunction mapHashToField(key, fieldOrder, isLE = false) {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024) throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? (0, utils_js_1.bytesToNumberLE)(key) : (0, utils_js_1.bytesToNumberBE)(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);\n}","map":{"version":3,"names":["exports","mod","pow","pow2","invert","tonelliShanks","FpSqrt","validateField","FpPow","FpInvertBatch","FpDiv","FpLegendre","FpIsSquare","nLength","Field","FpSqrtOdd","FpSqrtEven","hashToPrivateScalar","getFieldBytesLength","getMinHashLength","mapHashToField","utils_js_1","require","_0n","BigInt","_1n","_2n","_3n","_4n","_5n","_8n","_9n","_16n","a","b","result","num","power","modulo","Error","res","x","number","y","u","v","q","r","m","n","gcd","P","legendreC","Q","S","Z","p1div4","tonelliFast","Fp","root","eql","sqr","Q1div2","tonelliSlow","neg","ONE","g","mul","ZERO","t2","ge","sqrt3mod4","c1","sqrt5mod8","n2","nv","i","sub","isNegativeLE","FIELD_FIELDS","field","initial","ORDER","MASK","BYTES","BITS","opts","reduce","map","val","validateObject","f","p","d","nums","tmp","Array","length","lastMultiplied","acc","is0","inverted","inv","reduceRight","lhs","rhs","order","legendreConst","legendre","nBitLength","_nBitLength","undefined","toString","nByteLength","Math","ceil","bitLen","isLE","redef","sqrtP","Object","freeze","bitMask","create","isValid","isOdd","add","div","sqrN","addN","subN","mulN","sqrt","invertBatch","lst","cmov","c","toBytes","numberToBytesLE","numberToBytesBE","fromBytes","bytes","bytesToNumberLE","bytesToNumberBE","elm","hash","groupOrder","ensureBytes","hashLen","minLen","fieldOrder","bitLength","key","len","fieldLen","reduced"],"sources":["C:\\Users\\Adrien\\Desktop\\CryptoGrind - Copie\\client\\node_modules\\viem\\node_modules\\@noble\\curves\\src\\abstract\\modular.ts"],"sourcesContent":["/**\n * Utils for modular division and finite fields.\n * A finite field over 11 is integer number operations `mod 11`.\n * There is no division: it is replaced by modular multiplicative inverse.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nimport {\n  bitMask,\n  bytesToNumberBE,\n  bytesToNumberLE,\n  ensureBytes,\n  numberToBytesBE,\n  numberToBytesLE,\n  validateObject,\n} from './utils.js';\n\n// prettier-ignore\nconst _0n = BigInt(0), _1n = BigInt(1), _2n = /* @__PURE__ */ BigInt(2), _3n = /* @__PURE__ */ BigInt(3);\n// prettier-ignore\nconst _4n = /* @__PURE__ */ BigInt(4), _5n = /* @__PURE__ */ BigInt(5), _8n = /* @__PURE__ */ BigInt(8);\n// prettier-ignore\nconst _9n =/* @__PURE__ */ BigInt(9), _16n = /* @__PURE__ */ BigInt(16);\n\n// Calculates a modulo b\nexport function mod(a: bigint, b: bigint): bigint {\n  const result = a % b;\n  return result >= _0n ? result : b + result;\n}\n/**\n * Efficiently raise num to power and do modular division.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n * @todo use field version && remove\n * @example\n * pow(2n, 6n, 11n) // 64n % 11n == 9n\n */\nexport function pow(num: bigint, power: bigint, modulo: bigint): bigint {\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (modulo <= _0n) throw new Error('invalid modulus');\n  if (modulo === _1n) return _0n;\n  let res = _1n;\n  while (power > _0n) {\n    if (power & _1n) res = (res * num) % modulo;\n    num = (num * num) % modulo;\n    power >>= _1n;\n  }\n  return res;\n}\n\n/** Does `x^(2^power)` mod p. `pow2(30, 4)` == `30^(2^4)` */\nexport function pow2(x: bigint, power: bigint, modulo: bigint): bigint {\n  let res = x;\n  while (power-- > _0n) {\n    res *= res;\n    res %= modulo;\n  }\n  return res;\n}\n\n/**\n * Inverses number over modulo.\n * Implemented using [Euclidean GCD](https://brilliant.org/wiki/extended-euclidean-algorithm/).\n */\nexport function invert(number: bigint, modulo: bigint): bigint {\n  if (number === _0n) throw new Error('invert: expected non-zero number');\n  if (modulo <= _0n) throw new Error('invert: expected positive modulus, got ' + modulo);\n  // Fermat's little theorem \"CT-like\" version inv(n) = n^(m-2) mod m is 30x slower.\n  let a = mod(number, modulo);\n  let b = modulo;\n  // prettier-ignore\n  let x = _0n, y = _1n, u = _1n, v = _0n;\n  while (a !== _0n) {\n    // JIT applies optimization if those two lines follow each other\n    const q = b / a;\n    const r = b % a;\n    const m = x - u * q;\n    const n = y - v * q;\n    // prettier-ignore\n    b = a, a = r, x = u, y = v, u = m, v = n;\n  }\n  const gcd = b;\n  if (gcd !== _1n) throw new Error('invert: does not exist');\n  return mod(x, modulo);\n}\n\n/**\n * Tonelli-Shanks square root search algorithm.\n * 1. https://eprint.iacr.org/2012/685.pdf (page 12)\n * 2. Square Roots from 1; 24, 51, 10 to Dan Shanks\n * Will start an infinite loop if field order P is not prime.\n * @param P field order\n * @returns function that takes field Fp (created from P) and number n\n */\nexport function tonelliShanks(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // Legendre constant: used to calculate Legendre symbol (a | p),\n  // which denotes the value of a^((p-1)/2) (mod p).\n  // (a | p) ≡ 1    if a is a square (mod p)\n  // (a | p) ≡ -1   if a is not a square (mod p)\n  // (a | p) ≡ 0    if a ≡ 0 (mod p)\n  const legendreC = (P - _1n) / _2n;\n\n  let Q: bigint, S: number, Z: bigint;\n  // Step 1: By factoring out powers of 2 from p - 1,\n  // find q and s such that p - 1 = q*(2^s) with q odd\n  for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++);\n\n  // Step 2: Select a non-square z such that (z | p) ≡ -1 and set c ≡ zq\n  for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++) {\n    // Crash instead of infinity loop, we cannot reasonable count until P.\n    if (Z > 1000) throw new Error('Cannot find square root: likely non-prime P');\n  }\n\n  // Fast-path\n  if (S === 1) {\n    const p1div4 = (P + _1n) / _4n;\n    return function tonelliFast<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Slow-path\n  const Q1div2 = (Q + _1n) / _2n;\n  return function tonelliSlow<T>(Fp: IField<T>, n: T): T {\n    // Step 0: Check that n is indeed a square: (n | p) should not be ≡ -1\n    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE)) throw new Error('Cannot find square root');\n    let r = S;\n    // TODO: will fail at Fp2/etc\n    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q); // will update both x and b\n    let x = Fp.pow(n, Q1div2); // first guess at the square root\n    let b = Fp.pow(n, Q); // first guess at the fudge factor\n\n    while (!Fp.eql(b, Fp.ONE)) {\n      if (Fp.eql(b, Fp.ZERO)) return Fp.ZERO; // https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm (4. If t = 0, return r = 0)\n      // Find m such b^(2^m)==1\n      let m = 1;\n      for (let t2 = Fp.sqr(b); m < r; m++) {\n        if (Fp.eql(t2, Fp.ONE)) break;\n        t2 = Fp.sqr(t2); // t2 *= t2\n      }\n      // NOTE: r-m-1 can be bigger than 32, need to convert to bigint before shift, otherwise there will be overflow\n      const ge = Fp.pow(g, _1n << BigInt(r - m - 1)); // ge = 2^(r-m-1)\n      g = Fp.sqr(ge); // g = ge * ge\n      x = Fp.mul(x, ge); // x *= ge\n      b = Fp.mul(b, g); // b *= g\n      r = m;\n    }\n    return x;\n  };\n}\n\n/**\n * Square root for a finite field. It will try to check if optimizations are applicable and fall back to 4:\n *\n * 1. P ≡ 3 (mod 4)\n * 2. P ≡ 5 (mod 8)\n * 3. P ≡ 9 (mod 16)\n * 4. Tonelli-Shanks algorithm\n *\n * Different algorithms can give different roots, it is up to user to decide which one they want.\n * For example there is FpSqrtOdd/FpSqrtEven to choice root based on oddness (used for hash-to-curve).\n */\nexport function FpSqrt(P: bigint): <T>(Fp: IField<T>, n: T) => T {\n  // P ≡ 3 (mod 4)\n  // √n = n^((P+1)/4)\n  if (P % _4n === _3n) {\n    // Not all roots possible!\n    // const ORDER =\n    //   0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaabn;\n    // const NUM = 72057594037927816n;\n    const p1div4 = (P + _1n) / _4n;\n    return function sqrt3mod4<T>(Fp: IField<T>, n: T) {\n      const root = Fp.pow(n, p1div4);\n      // Throw if root**2 != n\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // Atkin algorithm for q ≡ 5 (mod 8), https://eprint.iacr.org/2012/685.pdf (page 10)\n  if (P % _8n === _5n) {\n    const c1 = (P - _5n) / _8n;\n    return function sqrt5mod8<T>(Fp: IField<T>, n: T) {\n      const n2 = Fp.mul(n, _2n);\n      const v = Fp.pow(n2, c1);\n      const nv = Fp.mul(n, v);\n      const i = Fp.mul(Fp.mul(nv, _2n), v);\n      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));\n      if (!Fp.eql(Fp.sqr(root), n)) throw new Error('Cannot find square root');\n      return root;\n    };\n  }\n\n  // P ≡ 9 (mod 16)\n  if (P % _16n === _9n) {\n    // NOTE: tonelli is too slow for bls-Fp2 calculations even on start\n    // Means we cannot use sqrt for constants at all!\n    //\n    // const c1 = Fp.sqrt(Fp.negate(Fp.ONE)); //  1. c1 = sqrt(-1) in F, i.e., (c1^2) == -1 in F\n    // const c2 = Fp.sqrt(c1);                //  2. c2 = sqrt(c1) in F, i.e., (c2^2) == c1 in F\n    // const c3 = Fp.sqrt(Fp.negate(c1));     //  3. c3 = sqrt(-c1) in F, i.e., (c3^2) == -c1 in F\n    // const c4 = (P + _7n) / _16n;           //  4. c4 = (q + 7) / 16        # Integer arithmetic\n    // sqrt = (x) => {\n    //   let tv1 = Fp.pow(x, c4);             //  1. tv1 = x^c4\n    //   let tv2 = Fp.mul(c1, tv1);           //  2. tv2 = c1 * tv1\n    //   const tv3 = Fp.mul(c2, tv1);         //  3. tv3 = c2 * tv1\n    //   let tv4 = Fp.mul(c3, tv1);           //  4. tv4 = c3 * tv1\n    //   const e1 = Fp.equals(Fp.square(tv2), x); //  5.  e1 = (tv2^2) == x\n    //   const e2 = Fp.equals(Fp.square(tv3), x); //  6.  e2 = (tv3^2) == x\n    //   tv1 = Fp.cmov(tv1, tv2, e1); //  7. tv1 = CMOV(tv1, tv2, e1)  # Select tv2 if (tv2^2) == x\n    //   tv2 = Fp.cmov(tv4, tv3, e2); //  8. tv2 = CMOV(tv4, tv3, e2)  # Select tv3 if (tv3^2) == x\n    //   const e3 = Fp.equals(Fp.square(tv2), x); //  9.  e3 = (tv2^2) == x\n    //   return Fp.cmov(tv1, tv2, e3); //  10.  z = CMOV(tv1, tv2, e3)  # Select the sqrt from tv1 and tv2\n    // }\n  }\n  // Other cases: Tonelli-Shanks algorithm\n  return tonelliShanks(P);\n}\n\n// Little-endian check for first LE bit (last BE bit);\nexport const isNegativeLE = (num: bigint, modulo: bigint): boolean =>\n  (mod(num, modulo) & _1n) === _1n;\n\n/** Field is not always over prime: for example, Fp2 has ORDER(q)=p^m. */\nexport interface IField<T> {\n  ORDER: bigint;\n  isLE: boolean;\n  BYTES: number;\n  BITS: number;\n  MASK: bigint;\n  ZERO: T;\n  ONE: T;\n  // 1-arg\n  create: (num: T) => T;\n  isValid: (num: T) => boolean;\n  is0: (num: T) => boolean;\n  neg(num: T): T;\n  inv(num: T): T;\n  sqrt(num: T): T;\n  sqr(num: T): T;\n  // 2-args\n  eql(lhs: T, rhs: T): boolean;\n  add(lhs: T, rhs: T): T;\n  sub(lhs: T, rhs: T): T;\n  mul(lhs: T, rhs: T | bigint): T;\n  pow(lhs: T, power: bigint): T;\n  div(lhs: T, rhs: T | bigint): T;\n  // N for NonNormalized (for now)\n  addN(lhs: T, rhs: T): T;\n  subN(lhs: T, rhs: T): T;\n  mulN(lhs: T, rhs: T | bigint): T;\n  sqrN(num: T): T;\n\n  // Optional\n  // Should be same as sgn0 function in\n  // [RFC9380](https://www.rfc-editor.org/rfc/rfc9380#section-4.1).\n  // NOTE: sgn0 is 'negative in LE', which is same as odd. And negative in LE is kinda strange definition anyway.\n  isOdd?(num: T): boolean; // Odd instead of even since we have it for Fp2\n  // legendre?(num: T): T;\n  pow(lhs: T, power: bigint): T;\n  invertBatch: (lst: T[]) => T[];\n  toBytes(num: T): Uint8Array;\n  fromBytes(bytes: Uint8Array): T;\n  // If c is False, CMOV returns a, otherwise it returns b.\n  cmov(a: T, b: T, c: boolean): T;\n}\n// prettier-ignore\nconst FIELD_FIELDS = [\n  'create', 'isValid', 'is0', 'neg', 'inv', 'sqrt', 'sqr',\n  'eql', 'add', 'sub', 'mul', 'pow', 'div',\n  'addN', 'subN', 'mulN', 'sqrN'\n] as const;\nexport function validateField<T>(field: IField<T>): IField<T> {\n  const initial = {\n    ORDER: 'bigint',\n    MASK: 'bigint',\n    BYTES: 'isSafeInteger',\n    BITS: 'isSafeInteger',\n  } as Record<string, string>;\n  const opts = FIELD_FIELDS.reduce((map, val: string) => {\n    map[val] = 'function';\n    return map;\n  }, initial);\n  return validateObject(field, opts);\n}\n\n// Generic field functions\n\n/**\n * Same as `pow` but for Fp: non-constant-time.\n * Unsafe in some contexts: uses ladder, so can expose bigint bits.\n */\nexport function FpPow<T>(f: IField<T>, num: T, power: bigint): T {\n  // Should have same speed as pow for bigints\n  // TODO: benchmark!\n  if (power < _0n) throw new Error('invalid exponent, negatives unsupported');\n  if (power === _0n) return f.ONE;\n  if (power === _1n) return num;\n  let p = f.ONE;\n  let d = num;\n  while (power > _0n) {\n    if (power & _1n) p = f.mul(p, d);\n    d = f.sqr(d);\n    power >>= _1n;\n  }\n  return p;\n}\n\n/**\n * Efficiently invert an array of Field elements.\n * `inv(0)` will return `undefined` here: make sure to throw an error.\n */\nexport function FpInvertBatch<T>(f: IField<T>, nums: T[]): T[] {\n  const tmp = new Array(nums.length);\n  // Walk from first to last, multiply them by each other MOD p\n  const lastMultiplied = nums.reduce((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = acc;\n    return f.mul(acc, num);\n  }, f.ONE);\n  // Invert last element\n  const inverted = f.inv(lastMultiplied);\n  // Walk from last to first, multiply them by inverted each other MOD p\n  nums.reduceRight((acc, num, i) => {\n    if (f.is0(num)) return acc;\n    tmp[i] = f.mul(acc, tmp[i]);\n    return f.mul(acc, num);\n  }, inverted);\n  return tmp;\n}\n\nexport function FpDiv<T>(f: IField<T>, lhs: T, rhs: T | bigint): T {\n  return f.mul(lhs, typeof rhs === 'bigint' ? invert(rhs, f.ORDER) : f.inv(rhs));\n}\n\n/**\n * Legendre symbol.\n * * (a | p) ≡ 1    if a is a square (mod p), quadratic residue\n * * (a | p) ≡ -1   if a is not a square (mod p), quadratic non residue\n * * (a | p) ≡ 0    if a ≡ 0 (mod p)\n */\nexport function FpLegendre(order: bigint): <T>(f: IField<T>, x: T) => T {\n  const legendreConst = (order - _1n) / _2n; // Integer arithmetic\n  return <T>(f: IField<T>, x: T): T => f.pow(x, legendreConst);\n}\n\n// This function returns True whenever the value x is a square in the field F.\nexport function FpIsSquare<T>(f: IField<T>): (x: T) => boolean {\n  const legendre = FpLegendre(f.ORDER);\n  return (x: T): boolean => {\n    const p = legendre(f, x);\n    return f.eql(p, f.ZERO) || f.eql(p, f.ONE);\n  };\n}\n\n// CURVE.n lengths\nexport function nLength(\n  n: bigint,\n  nBitLength?: number\n): {\n  nBitLength: number;\n  nByteLength: number;\n} {\n  // Bit size, byte size of CURVE.n\n  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;\n  const nByteLength = Math.ceil(_nBitLength / 8);\n  return { nBitLength: _nBitLength, nByteLength };\n}\n\ntype FpField = IField<bigint> & Required<Pick<IField<bigint>, 'isOdd'>>;\n/**\n * Initializes a finite field over prime.\n * Major performance optimizations:\n * * a) denormalized operations like mulN instead of mul\n * * b) same object shape: never add or remove keys\n * * c) Object.freeze\n * Fragile: always run a benchmark on a change.\n * Security note: operations don't check 'isValid' for all elements for performance reasons,\n * it is caller responsibility to check this.\n * This is low-level code, please make sure you know what you're doing.\n * @param ORDER prime positive bigint\n * @param bitLen how many bits the field consumes\n * @param isLE (def: false) if encoding / decoding should be in little-endian\n * @param redef optional faster redefinitions of sqrt and other methods\n */\nexport function Field(\n  ORDER: bigint,\n  bitLen?: number,\n  isLE = false,\n  redef: Partial<IField<bigint>> = {}\n): Readonly<FpField> {\n  if (ORDER <= _0n) throw new Error('invalid field: expected ORDER > 0, got ' + ORDER);\n  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);\n  if (BYTES > 2048) throw new Error('invalid field: expected ORDER of <= 2048 bytes');\n  let sqrtP: ReturnType<typeof FpSqrt>; // cached sqrtP\n  const f: Readonly<FpField> = Object.freeze({\n    ORDER,\n    isLE,\n    BITS,\n    BYTES,\n    MASK: bitMask(BITS),\n    ZERO: _0n,\n    ONE: _1n,\n    create: (num) => mod(num, ORDER),\n    isValid: (num) => {\n      if (typeof num !== 'bigint')\n        throw new Error('invalid field element: expected bigint, got ' + typeof num);\n      return _0n <= num && num < ORDER; // 0 is valid element, but it's not invertible\n    },\n    is0: (num) => num === _0n,\n    isOdd: (num) => (num & _1n) === _1n,\n    neg: (num) => mod(-num, ORDER),\n    eql: (lhs, rhs) => lhs === rhs,\n\n    sqr: (num) => mod(num * num, ORDER),\n    add: (lhs, rhs) => mod(lhs + rhs, ORDER),\n    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),\n    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),\n    pow: (num, power) => FpPow(f, num, power),\n    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),\n\n    // Same as above, but doesn't normalize\n    sqrN: (num) => num * num,\n    addN: (lhs, rhs) => lhs + rhs,\n    subN: (lhs, rhs) => lhs - rhs,\n    mulN: (lhs, rhs) => lhs * rhs,\n\n    inv: (num) => invert(num, ORDER),\n    sqrt:\n      redef.sqrt ||\n      ((n) => {\n        if (!sqrtP) sqrtP = FpSqrt(ORDER);\n        return sqrtP(f, n);\n      }),\n    invertBatch: (lst) => FpInvertBatch(f, lst),\n    // TODO: do we really need constant cmov?\n    // We don't have const-time bigints anyway, so probably will be not very useful\n    cmov: (a, b, c) => (c ? b : a),\n    toBytes: (num) => (isLE ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES)),\n    fromBytes: (bytes) => {\n      if (bytes.length !== BYTES)\n        throw new Error('Field.fromBytes: expected ' + BYTES + ' bytes, got ' + bytes.length);\n      return isLE ? bytesToNumberLE(bytes) : bytesToNumberBE(bytes);\n    },\n  } as FpField);\n  return Object.freeze(f);\n}\n\nexport function FpSqrtOdd<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? root : Fp.neg(root);\n}\n\nexport function FpSqrtEven<T>(Fp: IField<T>, elm: T): T {\n  if (!Fp.isOdd) throw new Error(\"Field doesn't have isOdd\");\n  const root = Fp.sqrt(elm);\n  return Fp.isOdd(root) ? Fp.neg(root) : root;\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Same as mapKeyToField, but accepts less bytes (40 instead of 48 for 32-byte field).\n * Which makes it slightly more biased, less secure.\n * @deprecated use `mapKeyToField` instead\n */\nexport function hashToPrivateScalar(\n  hash: string | Uint8Array,\n  groupOrder: bigint,\n  isLE = false\n): bigint {\n  hash = ensureBytes('privateHash', hash);\n  const hashLen = hash.length;\n  const minLen = nLength(groupOrder).nByteLength + 8;\n  if (minLen < 24 || hashLen < minLen || hashLen > 1024)\n    throw new Error(\n      'hashToPrivateScalar: expected ' + minLen + '-1024 bytes of input, got ' + hashLen\n    );\n  const num = isLE ? bytesToNumberLE(hash) : bytesToNumberBE(hash);\n  return mod(num, groupOrder - _1n) + _1n;\n}\n\n/**\n * Returns total number of bytes consumed by the field element.\n * For example, 32 bytes for usual 256-bit weierstrass curve.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of field\n */\nexport function getFieldBytesLength(fieldOrder: bigint): number {\n  if (typeof fieldOrder !== 'bigint') throw new Error('field order must be bigint');\n  const bitLength = fieldOrder.toString(2).length;\n  return Math.ceil(bitLength / 8);\n}\n\n/**\n * Returns minimal amount of bytes that can be safely reduced\n * by field order.\n * Should be 2^-128 for 128-bit curve such as P256.\n * @param fieldOrder number of field elements, usually CURVE.n\n * @returns byte length of target hash\n */\nexport function getMinHashLength(fieldOrder: bigint): number {\n  const length = getFieldBytesLength(fieldOrder);\n  return length + Math.ceil(length / 2);\n}\n\n/**\n * \"Constant-time\" private key generation utility.\n * Can take (n + n/2) or more bytes of uniform input e.g. from CSPRNG or KDF\n * and convert them into private scalar, with the modulo bias being negligible.\n * Needs at least 48 bytes of input for 32-byte private key.\n * https://research.kudelskisecurity.com/2020/07/28/the-definitive-guide-to-modulo-bias-and-how-to-avoid-it/\n * FIPS 186-5, A.2 https://csrc.nist.gov/publications/detail/fips/186/5/final\n * RFC 9380, https://www.rfc-editor.org/rfc/rfc9380#section-5\n * @param hash hash output from SHA3 or a similar function\n * @param groupOrder size of subgroup - (e.g. secp256k1.CURVE.n)\n * @param isLE interpret hash bytes as LE num\n * @returns valid private scalar\n */\nexport function mapHashToField(key: Uint8Array, fieldOrder: bigint, isLE = false): Uint8Array {\n  const len = key.length;\n  const fieldLen = getFieldBytesLength(fieldOrder);\n  const minLen = getMinHashLength(fieldOrder);\n  // No small numbers: need to understand bias story. No huge numbers: easier to detect JS timings.\n  if (len < 16 || len < minLen || len > 1024)\n    throw new Error('expected ' + minLen + '-1024 bytes of input, got ' + len);\n  const num = isLE ? bytesToNumberLE(key) : bytesToNumberBE(key);\n  // `mod(x, 11)` can sometimes produce 0. `mod(x, 10) + 1` is the same, but no 0\n  const reduced = mod(num, fieldOrder - _1n) + _1n;\n  return isLE ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}