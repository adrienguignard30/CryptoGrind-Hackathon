{"ast":null,"code":"\"use strict\";\n\n/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.notImplemented = exports.bitMask = void 0;\nexports.isBytes = isBytes;\nexports.abytes = abytes;\nexports.abool = abool;\nexports.numberToHexUnpadded = numberToHexUnpadded;\nexports.hexToNumber = hexToNumber;\nexports.bytesToHex = bytesToHex;\nexports.hexToBytes = hexToBytes;\nexports.bytesToNumberBE = bytesToNumberBE;\nexports.bytesToNumberLE = bytesToNumberLE;\nexports.numberToBytesBE = numberToBytesBE;\nexports.numberToBytesLE = numberToBytesLE;\nexports.numberToVarBytesBE = numberToVarBytesBE;\nexports.ensureBytes = ensureBytes;\nexports.concatBytes = concatBytes;\nexports.equalBytes = equalBytes;\nexports.utf8ToBytes = utf8ToBytes;\nexports.inRange = inRange;\nexports.aInRange = aInRange;\nexports.bitLen = bitLen;\nexports.bitGet = bitGet;\nexports.bitSet = bitSet;\nexports.createHmacDrbg = createHmacDrbg;\nexports.validateObject = validateObject;\nexports.memoized = memoized;\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */BigInt(0);\nconst _1n = /* @__PURE__ */BigInt(1);\nfunction isBytes(a) {\n  return a instanceof Uint8Array || ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array';\n}\nfunction abytes(item) {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\nfunction abool(title, value) {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\nfunction numberToHexUnpadded(num) {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\nfunction hexToNumber(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin =\n// @ts-ignore\ntypeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */Array.from({\n  length: 256\n}, (_, i) => i.toString(16).padStart(2, '0'));\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nfunction bytesToHex(bytes) {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n// We use optimized technique to convert hex string to byte array\nconst asciis = {\n  _0: 48,\n  _9: 57,\n  A: 65,\n  F: 70,\n  a: 97,\n  f: 102\n};\nfunction asciiToBase16(ch) {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nfunction hexToBytes(hex) {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n// BE: Big Endian, LE: Little Endian\nfunction bytesToNumberBE(bytes) {\n  return hexToNumber(bytesToHex(bytes));\n}\nfunction bytesToNumberLE(bytes) {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\nfunction numberToBytesBE(n, len) {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nfunction numberToBytesLE(n, len) {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nfunction numberToVarBytesBE(n) {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nfunction ensureBytes(title, hex, expectedLength) {\n  let res;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength) throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n/**\n * Copies several Uint8Arrays into one.\n */\nfunction concatBytes(...arrays) {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n// Compares 2 u8a-s in kinda constant time\nfunction equalBytes(a, b) {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nfunction utf8ToBytes(str) {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n// Is positive bigint\nconst isPosBig = n => typeof n === 'bigint' && _0n <= n;\nfunction inRange(n, min, max) {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nfunction aInRange(title, n, min, max) {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max)) throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n// Bit operations\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nfunction bitLen(n) {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nfunction bitGet(n, pos) {\n  return n >> BigInt(pos) & _1n;\n}\n/**\n * Sets single bit at position.\n */\nfunction bitSet(n, pos, value) {\n  return n | (value ? _1n : _0n) << BigInt(pos);\n}\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nconst bitMask = n => (_1n << BigInt(n)) - _1n;\nexports.bitMask = bitMask;\n// DRBG\nconst u8n = len => new Uint8Array(len); // creates Uint8Array\nconst u8fr = arr => Uint8Array.from(arr); // another shortcut\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nfunction createHmacDrbg(hashLen, qByteLen, hmacFn) {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed, pred) => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n// Validating curves and fields\nconst validatorFns = {\n  bigint: val => typeof val === 'bigint',\n  function: val => typeof val === 'function',\n  boolean: val => typeof val === 'boolean',\n  string: val => typeof val === 'string',\n  stringOrUint8Array: val => typeof val === 'string' || isBytes(val),\n  isSafeInteger: val => Number.isSafeInteger(val),\n  array: val => Array.isArray(val),\n  field: (val, object) => object.Fp.isValid(val),\n  hash: val => typeof val === 'function' && Number.isSafeInteger(val.outputLen)\n};\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\nfunction validateObject(object, validators, optValidators = {}) {\n  const checkField = (fieldName, type, isOptional) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n    const val = object[fieldName];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error('param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val);\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n/**\n * throws not implemented error\n */\nconst notImplemented = () => {\n  throw new Error('not implemented');\n};\nexports.notImplemented = notImplemented;\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nfunction memoized(fn) {\n  const map = new WeakMap();\n  return (arg, ...args) => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}","map":{"version":3,"names":["exports","isBytes","abytes","abool","numberToHexUnpadded","hexToNumber","bytesToHex","hexToBytes","bytesToNumberBE","bytesToNumberLE","numberToBytesBE","numberToBytesLE","numberToVarBytesBE","ensureBytes","concatBytes","equalBytes","utf8ToBytes","inRange","aInRange","bitLen","bitGet","bitSet","createHmacDrbg","validateObject","memoized","_0n","BigInt","_1n","a","Uint8Array","ArrayBuffer","isView","constructor","name","item","Error","title","value","num","hex","toString","length","hasHexBuiltin","from","toHex","fromHex","hexes","Array","_","i","padStart","bytes","asciis","_0","_9","A","F","f","asciiToBase16","ch","hl","al","array","ai","hi","n1","charCodeAt","n2","undefined","char","reverse","n","len","expectedLength","res","e","arrays","sum","pad","set","b","diff","str","TextEncoder","encode","isPosBig","min","max","pos","bitMask","u8n","u8fr","arr","hashLen","qByteLen","hmacFn","v","k","reset","fill","h","reseed","seed","gen","out","sl","slice","push","genUntil","pred","validatorFns","bigint","val","function","boolean","string","stringOrUint8Array","isSafeInteger","Number","isArray","field","object","Fp","isValid","hash","outputLen","validators","optValidators","checkField","fieldName","type","isOptional","checkVal","String","Object","entries","notImplemented","fn","map","WeakMap","arg","args","get","computed"],"sources":["C:\\Users\\Adrien\\Desktop\\CryptoGrind - Copie\\client\\node_modules\\@noble\\curves\\src\\abstract\\utils.ts"],"sourcesContent":["/**\n * Hex, bytes and number utilities.\n * @module\n */\n/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */\n\n// 100 lines of code in the file are duplicated from noble-hashes (utils).\n// This is OK: `abstract` directory does not use noble-hashes.\n// User may opt-in into using different hashing library. This way, noble-hashes\n// won't be included into their bundle.\nconst _0n = /* @__PURE__ */ BigInt(0);\nconst _1n = /* @__PURE__ */ BigInt(1);\nexport type Hex = Uint8Array | string; // hex strings are accepted for simplicity\nexport type PrivKey = Hex | bigint; // bigints are accepted to ease learning curve\nexport type CHash = {\n  (message: Uint8Array | string): Uint8Array;\n  blockLen: number;\n  outputLen: number;\n  create(opts?: { dkLen?: number }): any; // For shake\n};\nexport type FHash = (message: Uint8Array | string) => Uint8Array;\n\nexport function isBytes(a: unknown): a is Uint8Array {\n  return a instanceof Uint8Array || (ArrayBuffer.isView(a) && a.constructor.name === 'Uint8Array');\n}\n\nexport function abytes(item: unknown): void {\n  if (!isBytes(item)) throw new Error('Uint8Array expected');\n}\n\nexport function abool(title: string, value: boolean): void {\n  if (typeof value !== 'boolean') throw new Error(title + ' boolean expected, got ' + value);\n}\n\nexport function numberToHexUnpadded(num: number | bigint): string {\n  const hex = num.toString(16);\n  return hex.length & 1 ? '0' + hex : hex;\n}\n\nexport function hexToNumber(hex: string): bigint {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  return hex === '' ? _0n : BigInt('0x' + hex); // Big Endian\n}\n\n// Built-in hex conversion https://caniuse.com/mdn-javascript_builtins_uint8array_fromhex\nconst hasHexBuiltin: boolean =\n  // @ts-ignore\n  typeof Uint8Array.from([]).toHex === 'function' && typeof Uint8Array.fromHex === 'function';\n\n// Array where index 0xf0 (240) is mapped to string 'f0'\nconst hexes = /* @__PURE__ */ Array.from({ length: 256 }, (_, i) =>\n  i.toString(16).padStart(2, '0')\n);\n\n/**\n * Convert byte array to hex string. Uses built-in function, when available.\n * @example bytesToHex(Uint8Array.from([0xca, 0xfe, 0x01, 0x23])) // 'cafe0123'\n */\nexport function bytesToHex(bytes: Uint8Array): string {\n  abytes(bytes);\n  // @ts-ignore\n  if (hasHexBuiltin) return bytes.toHex();\n  // pre-caching improves the speed 6x\n  let hex = '';\n  for (let i = 0; i < bytes.length; i++) {\n    hex += hexes[bytes[i]];\n  }\n  return hex;\n}\n\n// We use optimized technique to convert hex string to byte array\nconst asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 } as const;\nfunction asciiToBase16(ch: number): number | undefined {\n  if (ch >= asciis._0 && ch <= asciis._9) return ch - asciis._0; // '2' => 50-48\n  if (ch >= asciis.A && ch <= asciis.F) return ch - (asciis.A - 10); // 'B' => 66-(65-10)\n  if (ch >= asciis.a && ch <= asciis.f) return ch - (asciis.a - 10); // 'b' => 98-(97-10)\n  return;\n}\n\n/**\n * Convert hex string to byte array. Uses built-in function, when available.\n * @example hexToBytes('cafe0123') // Uint8Array.from([0xca, 0xfe, 0x01, 0x23])\n */\nexport function hexToBytes(hex: string): Uint8Array {\n  if (typeof hex !== 'string') throw new Error('hex string expected, got ' + typeof hex);\n  // @ts-ignore\n  if (hasHexBuiltin) return Uint8Array.fromHex(hex);\n  const hl = hex.length;\n  const al = hl / 2;\n  if (hl % 2) throw new Error('hex string expected, got unpadded hex of length ' + hl);\n  const array = new Uint8Array(al);\n  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {\n    const n1 = asciiToBase16(hex.charCodeAt(hi));\n    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));\n    if (n1 === undefined || n2 === undefined) {\n      const char = hex[hi] + hex[hi + 1];\n      throw new Error('hex string expected, got non-hex character \"' + char + '\" at index ' + hi);\n    }\n    array[ai] = n1 * 16 + n2; // multiply first octet, e.g. 'a3' => 10*16+3 => 160 + 3 => 163\n  }\n  return array;\n}\n\n// BE: Big Endian, LE: Little Endian\nexport function bytesToNumberBE(bytes: Uint8Array): bigint {\n  return hexToNumber(bytesToHex(bytes));\n}\nexport function bytesToNumberLE(bytes: Uint8Array): bigint {\n  abytes(bytes);\n  return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));\n}\n\nexport function numberToBytesBE(n: number | bigint, len: number): Uint8Array {\n  return hexToBytes(n.toString(16).padStart(len * 2, '0'));\n}\nexport function numberToBytesLE(n: number | bigint, len: number): Uint8Array {\n  return numberToBytesBE(n, len).reverse();\n}\n// Unpadded, rarely used\nexport function numberToVarBytesBE(n: number | bigint): Uint8Array {\n  return hexToBytes(numberToHexUnpadded(n));\n}\n\n/**\n * Takes hex string or Uint8Array, converts to Uint8Array.\n * Validates output length.\n * Will throw error for other types.\n * @param title descriptive title for an error e.g. 'private key'\n * @param hex hex string or Uint8Array\n * @param expectedLength optional, will compare to result array's length\n * @returns\n */\nexport function ensureBytes(title: string, hex: Hex, expectedLength?: number): Uint8Array {\n  let res: Uint8Array;\n  if (typeof hex === 'string') {\n    try {\n      res = hexToBytes(hex);\n    } catch (e) {\n      throw new Error(title + ' must be hex string or Uint8Array, cause: ' + e);\n    }\n  } else if (isBytes(hex)) {\n    // Uint8Array.from() instead of hash.slice() because node.js Buffer\n    // is instance of Uint8Array, and its slice() creates **mutable** copy\n    res = Uint8Array.from(hex);\n  } else {\n    throw new Error(title + ' must be hex string or Uint8Array');\n  }\n  const len = res.length;\n  if (typeof expectedLength === 'number' && len !== expectedLength)\n    throw new Error(title + ' of length ' + expectedLength + ' expected, got ' + len);\n  return res;\n}\n\n/**\n * Copies several Uint8Arrays into one.\n */\nexport function concatBytes(...arrays: Uint8Array[]): Uint8Array {\n  let sum = 0;\n  for (let i = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    abytes(a);\n    sum += a.length;\n  }\n  const res = new Uint8Array(sum);\n  for (let i = 0, pad = 0; i < arrays.length; i++) {\n    const a = arrays[i];\n    res.set(a, pad);\n    pad += a.length;\n  }\n  return res;\n}\n\n// Compares 2 u8a-s in kinda constant time\nexport function equalBytes(a: Uint8Array, b: Uint8Array): boolean {\n  if (a.length !== b.length) return false;\n  let diff = 0;\n  for (let i = 0; i < a.length; i++) diff |= a[i] ^ b[i];\n  return diff === 0;\n}\n\n// Global symbols in both browsers and Node.js since v11\n// See https://github.com/microsoft/TypeScript/issues/31535\ndeclare const TextEncoder: any;\n\n/**\n * @example utf8ToBytes('abc') // new Uint8Array([97, 98, 99])\n */\nexport function utf8ToBytes(str: string): Uint8Array {\n  if (typeof str !== 'string') throw new Error('string expected');\n  return new Uint8Array(new TextEncoder().encode(str)); // https://bugzil.la/1681809\n}\n\n// Is positive bigint\nconst isPosBig = (n: bigint) => typeof n === 'bigint' && _0n <= n;\n\nexport function inRange(n: bigint, min: bigint, max: bigint): boolean {\n  return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;\n}\n\n/**\n * Asserts min <= n < max. NOTE: It's < max and not <= max.\n * @example\n * aInRange('x', x, 1n, 256n); // would assume x is in (1n..255n)\n */\nexport function aInRange(title: string, n: bigint, min: bigint, max: bigint): void {\n  // Why min <= n < max and not a (min < n < max) OR b (min <= n <= max)?\n  // consider P=256n, min=0n, max=P\n  // - a for min=0 would require -1:          `inRange('x', x, -1n, P)`\n  // - b would commonly require subtraction:  `inRange('x', x, 0n, P - 1n)`\n  // - our way is the cleanest:               `inRange('x', x, 0n, P)\n  if (!inRange(n, min, max))\n    throw new Error('expected valid ' + title + ': ' + min + ' <= n < ' + max + ', got ' + n);\n}\n\n// Bit operations\n\n/**\n * Calculates amount of bits in a bigint.\n * Same as `n.toString(2).length`\n */\nexport function bitLen(n: bigint): number {\n  let len;\n  for (len = 0; n > _0n; n >>= _1n, len += 1);\n  return len;\n}\n\n/**\n * Gets single bit at position.\n * NOTE: first bit position is 0 (same as arrays)\n * Same as `!!+Array.from(n.toString(2)).reverse()[pos]`\n */\nexport function bitGet(n: bigint, pos: number): bigint {\n  return (n >> BigInt(pos)) & _1n;\n}\n\n/**\n * Sets single bit at position.\n */\nexport function bitSet(n: bigint, pos: number, value: boolean): bigint {\n  return n | ((value ? _1n : _0n) << BigInt(pos));\n}\n\n/**\n * Calculate mask for N bits. Not using ** operator with bigints because of old engines.\n * Same as BigInt(`0b${Array(i).fill('1').join('')}`)\n */\nexport const bitMask = (n: number): bigint => (_1n << BigInt(n)) - _1n;\n\n// DRBG\n\nconst u8n = (len: number) => new Uint8Array(len); // creates Uint8Array\nconst u8fr = (arr: ArrayLike<number>) => Uint8Array.from(arr); // another shortcut\ntype Pred<T> = (v: Uint8Array) => T | undefined;\n/**\n * Minimal HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n * @returns function that will call DRBG until 2nd arg returns something meaningful\n * @example\n *   const drbg = createHmacDRBG<Key>(32, 32, hmac);\n *   drbg(seed, bytesToKey); // bytesToKey must return Key or undefined\n */\nexport function createHmacDrbg<T>(\n  hashLen: number,\n  qByteLen: number,\n  hmacFn: (key: Uint8Array, ...messages: Uint8Array[]) => Uint8Array\n): (seed: Uint8Array, predicate: Pred<T>) => T {\n  if (typeof hashLen !== 'number' || hashLen < 2) throw new Error('hashLen must be a number');\n  if (typeof qByteLen !== 'number' || qByteLen < 2) throw new Error('qByteLen must be a number');\n  if (typeof hmacFn !== 'function') throw new Error('hmacFn must be a function');\n  // Step B, Step C: set hashLen to 8*ceil(hlen/8)\n  let v = u8n(hashLen); // Minimal non-full-spec HMAC-DRBG from NIST 800-90 for RFC6979 sigs.\n  let k = u8n(hashLen); // Steps B and C of RFC6979 3.2: set hashLen, in our case always same\n  let i = 0; // Iterations counter, will throw when over 1000\n  const reset = () => {\n    v.fill(1);\n    k.fill(0);\n    i = 0;\n  };\n  const h = (...b: Uint8Array[]) => hmacFn(k, v, ...b); // hmac(k)(v, ...values)\n  const reseed = (seed = u8n(0)) => {\n    // HMAC-DRBG reseed() function. Steps D-G\n    k = h(u8fr([0x00]), seed); // k = hmac(k || v || 0x00 || seed)\n    v = h(); // v = hmac(k || v)\n    if (seed.length === 0) return;\n    k = h(u8fr([0x01]), seed); // k = hmac(k || v || 0x01 || seed)\n    v = h(); // v = hmac(k || v)\n  };\n  const gen = () => {\n    // HMAC-DRBG generate() function\n    if (i++ >= 1000) throw new Error('drbg: tried 1000 values');\n    let len = 0;\n    const out: Uint8Array[] = [];\n    while (len < qByteLen) {\n      v = h();\n      const sl = v.slice();\n      out.push(sl);\n      len += v.length;\n    }\n    return concatBytes(...out);\n  };\n  const genUntil = (seed: Uint8Array, pred: Pred<T>): T => {\n    reset();\n    reseed(seed); // Steps D-G\n    let res: T | undefined = undefined; // Step H: grind until k is in [1..n-1]\n    while (!(res = pred(gen()))) reseed();\n    reset();\n    return res;\n  };\n  return genUntil;\n}\n\n// Validating curves and fields\n\nconst validatorFns = {\n  bigint: (val: any): boolean => typeof val === 'bigint',\n  function: (val: any): boolean => typeof val === 'function',\n  boolean: (val: any): boolean => typeof val === 'boolean',\n  string: (val: any): boolean => typeof val === 'string',\n  stringOrUint8Array: (val: any): boolean => typeof val === 'string' || isBytes(val),\n  isSafeInteger: (val: any): boolean => Number.isSafeInteger(val),\n  array: (val: any): boolean => Array.isArray(val),\n  field: (val: any, object: any): any => (object as any).Fp.isValid(val),\n  hash: (val: any): boolean => typeof val === 'function' && Number.isSafeInteger(val.outputLen),\n} as const;\ntype Validator = keyof typeof validatorFns;\ntype ValMap<T extends Record<string, any>> = { [K in keyof T]?: Validator };\n// type Record<K extends string | number | symbol, T> = { [P in K]: T; }\n\nexport function validateObject<T extends Record<string, any>>(\n  object: T,\n  validators: ValMap<T>,\n  optValidators: ValMap<T> = {}\n): T {\n  const checkField = (fieldName: keyof T, type: Validator, isOptional: boolean) => {\n    const checkVal = validatorFns[type];\n    if (typeof checkVal !== 'function') throw new Error('invalid validator function');\n\n    const val = object[fieldName as keyof typeof object];\n    if (isOptional && val === undefined) return;\n    if (!checkVal(val, object)) {\n      throw new Error(\n        'param ' + String(fieldName) + ' is invalid. Expected ' + type + ', got ' + val\n      );\n    }\n  };\n  for (const [fieldName, type] of Object.entries(validators)) checkField(fieldName, type!, false);\n  for (const [fieldName, type] of Object.entries(optValidators)) checkField(fieldName, type!, true);\n  return object;\n}\n// validate type tests\n// const o: { a: number; b: number; c: number } = { a: 1, b: 5, c: 6 };\n// const z0 = validateObject(o, { a: 'isSafeInteger' }, { c: 'bigint' }); // Ok!\n// // Should fail type-check\n// const z1 = validateObject(o, { a: 'tmp' }, { c: 'zz' });\n// const z2 = validateObject(o, { a: 'isSafeInteger' }, { c: 'zz' });\n// const z3 = validateObject(o, { test: 'boolean', z: 'bug' });\n// const z4 = validateObject(o, { a: 'boolean', z: 'bug' });\n\n/**\n * throws not implemented error\n */\nexport const notImplemented = (): never => {\n  throw new Error('not implemented');\n};\n\n/**\n * Memoizes (caches) computation result.\n * Uses WeakMap: the value is going auto-cleaned by GC after last reference is removed.\n */\nexport function memoized<T extends object, R, O extends any[]>(\n  fn: (arg: T, ...args: O) => R\n): (arg: T, ...args: O) => R {\n  const map = new WeakMap<T, R>();\n  return (arg: T, ...args: O): R => {\n    const val = map.get(arg);\n    if (val !== undefined) return val;\n    const computed = fn(arg, ...args);\n    map.set(arg, computed);\n    return computed;\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}