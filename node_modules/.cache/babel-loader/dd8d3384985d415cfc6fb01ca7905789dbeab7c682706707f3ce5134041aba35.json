{"ast":null,"code":"import { EventEmitter as A } from \"events\";\nimport { getAccountsFromNamespaces as b, getSdkError as S, isValidArray as E } from \"@walletconnect/utils\";\nimport { UniversalProvider as R } from \"@walletconnect/universal-provider\";\nconst T = \"wc\",\n  $ = \"ethereum_provider\",\n  j = `${T}@2:${$}:`,\n  q = \"https://rpc.walletconnect.org/v1/\",\n  u = [\"eth_sendTransaction\", \"personal_sign\"],\n  M = [\"eth_accounts\", \"eth_requestAccounts\", \"eth_sendRawTransaction\", \"eth_sign\", \"eth_signTransaction\", \"eth_signTypedData\", \"eth_signTypedData_v3\", \"eth_signTypedData_v4\", \"eth_sendTransaction\", \"personal_sign\", \"wallet_switchEthereumChain\", \"wallet_addEthereumChain\", \"wallet_getPermissions\", \"wallet_requestPermissions\", \"wallet_registerOnboarding\", \"wallet_watchAsset\", \"wallet_scanQRCode\", \"wallet_sendCalls\", \"wallet_getCapabilities\", \"wallet_getCallsStatus\", \"wallet_showCallsStatus\"],\n  m = [\"chainChanged\", \"accountsChanged\"],\n  O = [\"chainChanged\", \"accountsChanged\", \"message\", \"disconnect\", \"connect\"];\nvar N = Object.defineProperty,\n  D = Object.defineProperties,\n  U = Object.getOwnPropertyDescriptors,\n  P = Object.getOwnPropertySymbols,\n  Q = Object.prototype.hasOwnProperty,\n  L = Object.prototype.propertyIsEnumerable,\n  y = (a, t, s) => t in a ? N(a, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: s\n  }) : a[t] = s,\n  g = (a, t) => {\n    for (var s in t || (t = {})) Q.call(t, s) && y(a, s, t[s]);\n    if (P) for (var s of P(t)) L.call(t, s) && y(a, s, t[s]);\n    return a;\n  },\n  _ = (a, t) => D(a, U(t)),\n  o = (a, t, s) => y(a, typeof t != \"symbol\" ? t + \"\" : t, s);\nfunction v(a) {\n  return Number(a[0].split(\":\")[1]);\n}\nfunction C(a) {\n  return `0x${a.toString(16)}`;\n}\nfunction x(a) {\n  const {\n    chains: t,\n    optionalChains: s,\n    methods: i,\n    optionalMethods: e,\n    events: n,\n    optionalEvents: h,\n    rpcMap: l\n  } = a;\n  if (!E(t)) throw new Error(\"Invalid chains\");\n  const r = {\n      chains: t,\n      methods: i || u,\n      events: n || m,\n      rpcMap: g({}, t.length ? {\n        [v(t)]: l[v(t)]\n      } : {})\n    },\n    d = n?.filter(p => !m.includes(p)),\n    c = i?.filter(p => !u.includes(p));\n  if (!s && !h && !e && !(d != null && d.length) && !(c != null && c.length)) return {\n    required: t.length ? r : void 0\n  };\n  const I = d?.length && c?.length || !s,\n    f = {\n      chains: [...new Set(I ? r.chains.concat(s || []) : s)],\n      methods: [...new Set(r.methods.concat(e != null && e.length ? e : M))],\n      events: [...new Set(r.events.concat(h != null && h.length ? h : O))],\n      rpcMap: l\n    };\n  return {\n    required: t.length ? r : void 0,\n    optional: s.length ? f : void 0\n  };\n}\nclass w {\n  constructor() {\n    o(this, \"events\", new A()), o(this, \"namespace\", \"eip155\"), o(this, \"accounts\", []), o(this, \"signer\"), o(this, \"chainId\", 1), o(this, \"modal\"), o(this, \"rpc\"), o(this, \"STORAGE_KEY\", j), o(this, \"on\", (t, s) => (this.events.on(t, s), this)), o(this, \"once\", (t, s) => (this.events.once(t, s), this)), o(this, \"removeListener\", (t, s) => (this.events.removeListener(t, s), this)), o(this, \"off\", (t, s) => (this.events.off(t, s), this)), o(this, \"parseAccount\", t => this.isCompatibleChainId(t) ? this.parseAccountId(t).address : t), this.signer = {}, this.rpc = {};\n  }\n  static async init(t) {\n    const s = new w();\n    return await s.initialize(t), s;\n  }\n  async request(t, s) {\n    return await this.signer.request(t, this.formatChainId(this.chainId), s);\n  }\n  sendAsync(t, s, i) {\n    this.signer.sendAsync(t, s, this.formatChainId(this.chainId), i);\n  }\n  get connected() {\n    return this.signer.client ? this.signer.client.core.relayer.connected : !1;\n  }\n  get connecting() {\n    return this.signer.client ? this.signer.client.core.relayer.connecting : !1;\n  }\n  async enable() {\n    return this.session || (await this.connect()), await this.request({\n      method: \"eth_requestAccounts\"\n    });\n  }\n  async connect(t) {\n    if (!this.signer.client) throw new Error(\"Provider not initialized. Call init() first\");\n    this.loadConnectOpts(t);\n    const {\n      required: s,\n      optional: i\n    } = x(this.rpc);\n    try {\n      const e = await new Promise(async (h, l) => {\n        var r;\n        this.rpc.showQrModal && ((r = this.modal) == null || r.subscribeModal(c => {\n          !c.open && !this.signer.session && (this.signer.abortPairingAttempt(), l(new Error(\"Connection request reset. Please try again.\")));\n        }));\n        const d = t != null && t.scopedProperties ? {\n          [this.namespace]: t.scopedProperties\n        } : void 0;\n        await this.signer.connect(_(g({\n          namespaces: g({}, s && {\n            [this.namespace]: s\n          })\n        }, i && {\n          optionalNamespaces: {\n            [this.namespace]: i\n          }\n        }), {\n          pairingTopic: t?.pairingTopic,\n          scopedProperties: d\n        })).then(c => {\n          h(c);\n        }).catch(c => {\n          l(new Error(c.message));\n        });\n      });\n      if (!e) return;\n      const n = b(e.namespaces, [this.namespace]);\n      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : n), this.setAccounts(n), this.events.emit(\"connect\", {\n        chainId: C(this.chainId)\n      });\n    } catch (e) {\n      throw this.signer.logger.error(e), e;\n    } finally {\n      this.modal && this.modal.closeModal();\n    }\n  }\n  async authenticate(t, s) {\n    if (!this.signer.client) throw new Error(\"Provider not initialized. Call init() first\");\n    this.loadConnectOpts({\n      chains: t?.chains\n    });\n    try {\n      const i = await new Promise(async (n, h) => {\n          var l;\n          this.rpc.showQrModal && ((l = this.modal) == null || l.subscribeModal(r => {\n            !r.open && !this.signer.session && (this.signer.abortPairingAttempt(), h(new Error(\"Connection request reset. Please try again.\")));\n          })), await this.signer.authenticate(_(g({}, t), {\n            chains: this.rpc.chains\n          }), s).then(r => {\n            n(r);\n          }).catch(r => {\n            h(new Error(r.message));\n          });\n        }),\n        e = i.session;\n      if (e) {\n        const n = b(e.namespaces, [this.namespace]);\n        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : n), this.setAccounts(n), this.events.emit(\"connect\", {\n          chainId: C(this.chainId)\n        });\n      }\n      return i;\n    } catch (i) {\n      throw this.signer.logger.error(i), i;\n    } finally {\n      this.modal && this.modal.closeModal();\n    }\n  }\n  async disconnect() {\n    this.session && (await this.signer.disconnect()), this.reset();\n  }\n  get isWalletConnect() {\n    return !0;\n  }\n  get session() {\n    return this.signer.session;\n  }\n  registerEventListeners() {\n    this.signer.on(\"session_event\", t => {\n      const {\n          params: s\n        } = t,\n        {\n          event: i\n        } = s;\n      i.name === \"accountsChanged\" ? (this.accounts = this.parseAccounts(i.data), this.events.emit(\"accountsChanged\", this.accounts)) : i.name === \"chainChanged\" ? this.setChainId(this.formatChainId(i.data)) : this.events.emit(i.name, i.data), this.events.emit(\"session_event\", t);\n    }), this.signer.on(\"accountsChanged\", t => {\n      this.accounts = this.parseAccounts(t), this.events.emit(\"accountsChanged\", this.accounts);\n    }), this.signer.on(\"chainChanged\", t => {\n      const s = parseInt(t);\n      this.chainId = s, this.events.emit(\"chainChanged\", C(this.chainId)), this.persist();\n    }), this.signer.on(\"session_update\", t => {\n      this.events.emit(\"session_update\", t);\n    }), this.signer.on(\"session_delete\", t => {\n      this.reset(), this.events.emit(\"session_delete\", t), this.events.emit(\"disconnect\", _(g({}, S(\"USER_DISCONNECTED\")), {\n        data: t.topic,\n        name: \"USER_DISCONNECTED\"\n      }));\n    }), this.signer.on(\"display_uri\", t => {\n      var s, i;\n      this.rpc.showQrModal && ((s = this.modal) == null || s.closeModal(), (i = this.modal) == null || i.openModal({\n        uri: t\n      })), this.events.emit(\"display_uri\", t);\n    });\n  }\n  switchEthereumChain(t) {\n    this.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{\n        chainId: t.toString(16)\n      }]\n    });\n  }\n  isCompatibleChainId(t) {\n    return typeof t == \"string\" ? t.startsWith(`${this.namespace}:`) : !1;\n  }\n  formatChainId(t) {\n    return `${this.namespace}:${t}`;\n  }\n  parseChainId(t) {\n    return Number(t.split(\":\")[1]);\n  }\n  setChainIds(t) {\n    const s = t.filter(i => this.isCompatibleChainId(i)).map(i => this.parseChainId(i));\n    s.length && (this.chainId = s[0], this.events.emit(\"chainChanged\", C(this.chainId)), this.persist());\n  }\n  setChainId(t) {\n    if (this.isCompatibleChainId(t)) {\n      const s = this.parseChainId(t);\n      this.chainId = s, this.switchEthereumChain(s);\n    }\n  }\n  parseAccountId(t) {\n    const [s, i, e] = t.split(\":\");\n    return {\n      chainId: `${s}:${i}`,\n      address: e\n    };\n  }\n  setAccounts(t) {\n    this.accounts = t.filter(s => this.parseChainId(this.parseAccountId(s).chainId) === this.chainId).map(s => this.parseAccountId(s).address), this.events.emit(\"accountsChanged\", this.accounts);\n  }\n  getRpcConfig(t) {\n    var s, i;\n    const e = (s = t?.chains) != null ? s : [],\n      n = (i = t?.optionalChains) != null ? i : [],\n      h = e.concat(n);\n    if (!h.length) throw new Error(\"No chains specified in either `chains` or `optionalChains`\");\n    const l = e.length ? t?.methods || u : [],\n      r = e.length ? t?.events || m : [],\n      d = t?.optionalMethods || [],\n      c = t?.optionalEvents || [],\n      I = t?.rpcMap || this.buildRpcMap(h, t.projectId),\n      f = t?.qrModalOptions || void 0;\n    return {\n      chains: e?.map(p => this.formatChainId(p)),\n      optionalChains: n.map(p => this.formatChainId(p)),\n      methods: l,\n      events: r,\n      optionalMethods: d,\n      optionalEvents: c,\n      rpcMap: I,\n      showQrModal: !!(t != null && t.showQrModal),\n      qrModalOptions: f,\n      projectId: t.projectId,\n      metadata: t.metadata\n    };\n  }\n  buildRpcMap(t, s) {\n    const i = {};\n    return t.forEach(e => {\n      i[e] = this.getRpcUrl(e, s);\n    }), i;\n  }\n  async initialize(t) {\n    if (this.rpc = this.getRpcConfig(t), this.chainId = this.rpc.chains.length ? v(this.rpc.chains) : v(this.rpc.optionalChains), this.signer = await R.init({\n      projectId: this.rpc.projectId,\n      metadata: this.rpc.metadata,\n      disableProviderPing: t.disableProviderPing,\n      relayUrl: t.relayUrl,\n      storage: t.storage,\n      storageOptions: t.storageOptions,\n      customStoragePrefix: t.customStoragePrefix,\n      telemetryEnabled: t.telemetryEnabled,\n      logger: t.logger\n    }), this.registerEventListeners(), await this.loadPersistedSession(), this.rpc.showQrModal) {\n      let s;\n      try {\n        const {\n          WalletConnectModal: i\n        } = await import(\"@walletconnect/modal\");\n        s = i;\n      } catch {\n        throw new Error(\"To use QR modal, please install @walletconnect/modal package\");\n      }\n      if (s) try {\n        this.modal = new s(g({\n          projectId: this.rpc.projectId\n        }, this.rpc.qrModalOptions));\n      } catch (i) {\n        throw this.signer.logger.error(i), new Error(\"Could not generate WalletConnectModal Instance\");\n      }\n    }\n  }\n  loadConnectOpts(t) {\n    if (!t) return;\n    const {\n      chains: s,\n      optionalChains: i,\n      rpcMap: e\n    } = t;\n    s && E(s) && (this.rpc.chains = s.map(n => this.formatChainId(n)), s.forEach(n => {\n      this.rpc.rpcMap[n] = e?.[n] || this.getRpcUrl(n);\n    })), i && E(i) && (this.rpc.optionalChains = [], this.rpc.optionalChains = i?.map(n => this.formatChainId(n)), i.forEach(n => {\n      this.rpc.rpcMap[n] = e?.[n] || this.getRpcUrl(n);\n    }));\n  }\n  getRpcUrl(t, s) {\n    var i;\n    return ((i = this.rpc.rpcMap) == null ? void 0 : i[t]) || `${q}?chainId=eip155:${t}&projectId=${s || this.rpc.projectId}`;\n  }\n  async loadPersistedSession() {\n    if (this.session) try {\n      const t = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`),\n        s = this.session.namespaces[`${this.namespace}:${t}`] ? this.session.namespaces[`${this.namespace}:${t}`] : this.session.namespaces[this.namespace];\n      this.setChainIds(t ? [this.formatChainId(t)] : s?.accounts), this.setAccounts(s?.accounts);\n    } catch (t) {\n      this.signer.logger.error(\"Failed to load persisted session, clearing state...\"), this.signer.logger.error(t), await this.disconnect().catch(s => this.signer.logger.warn(s));\n    }\n  }\n  reset() {\n    this.chainId = 1, this.accounts = [];\n  }\n  persist() {\n    this.session && this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);\n  }\n  parseAccounts(t) {\n    return typeof t == \"string\" || t instanceof String ? [this.parseAccount(t)] : t.map(s => this.parseAccount(s));\n  }\n}\nconst z = w;\nexport { z as EthereumProvider, O as OPTIONAL_EVENTS, M as OPTIONAL_METHODS, m as REQUIRED_EVENTS, u as REQUIRED_METHODS, w as default };","map":{"version":3,"names":[],"sources":["C:\\Users\\Adrien\\Desktop\\CryptoGrind - Copie\\client\\node_modules\\@walletconnect\\ethereum-provider\\src\\constants\\values.ts","C:\\Users\\Adrien\\Desktop\\CryptoGrind - Copie\\client\\node_modules\\@walletconnect\\ethereum-provider\\src\\constants\\rpc.ts","C:\\Users\\Adrien\\Desktop\\CryptoGrind - Copie\\client\\node_modules\\@walletconnect\\ethereum-provider\\src\\EthereumProvider.ts","C:\\Users\\Adrien\\Desktop\\CryptoGrind - Copie\\client\\node_modules\\@walletconnect\\ethereum-provider\\src\\index.ts"],"sourcesContent":["export const PROTOCOL = \"wc\";\nexport const WC_VERSION = 2;\nexport const CONTEXT = \"ethereum_provider\";\nexport const STORAGE_KEY = `${PROTOCOL}@${WC_VERSION}:${CONTEXT}:`;\nexport const RPC_URL = \"https://rpc.walletconnect.org/v1/\";\n","export const REQUIRED_METHODS = [\"eth_sendTransaction\", \"personal_sign\"];\nexport const OPTIONAL_METHODS = [\n  \"eth_accounts\",\n  \"eth_requestAccounts\",\n  \"eth_sendRawTransaction\",\n  \"eth_sign\",\n  \"eth_signTransaction\",\n  \"eth_signTypedData\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData_v4\",\n  \"eth_sendTransaction\",\n  \"personal_sign\",\n  \"wallet_switchEthereumChain\",\n  \"wallet_addEthereumChain\",\n  \"wallet_getPermissions\",\n  \"wallet_requestPermissions\",\n  \"wallet_registerOnboarding\",\n  \"wallet_watchAsset\",\n  \"wallet_scanQRCode\",\n  \"wallet_sendCalls\",\n  \"wallet_getCapabilities\",\n  \"wallet_getCallsStatus\",\n  \"wallet_showCallsStatus\",\n];\nexport const REQUIRED_EVENTS = [\"chainChanged\", \"accountsChanged\"];\nexport const OPTIONAL_EVENTS = [\n  \"chainChanged\",\n  \"accountsChanged\",\n  \"message\",\n  \"disconnect\",\n  \"connect\",\n];\n","import { EventEmitter } from \"events\";\nimport { getAccountsFromNamespaces, getSdkError, isValidArray } from \"@walletconnect/utils\";\nimport { KeyValueStorageOptions } from \"@walletconnect/keyvaluestorage\";\nimport {\n  IEthereumProvider as IProvider,\n  IEthereumProviderEvents,\n  ProviderAccounts,\n  RequestArguments,\n  QrModalOptions,\n} from \"./types\";\nimport {\n  Metadata,\n  Namespace,\n  UniversalProvider,\n  UniversalProviderOpts,\n} from \"@walletconnect/universal-provider\";\nimport { AuthTypes, SessionTypes, SignClientTypes } from \"@walletconnect/types\";\nimport { JsonRpcResult } from \"@walletconnect/jsonrpc-types\";\nimport {\n  STORAGE_KEY,\n  REQUIRED_METHODS,\n  REQUIRED_EVENTS,\n  RPC_URL,\n  OPTIONAL_METHODS,\n  OPTIONAL_EVENTS,\n} from \"./constants\";\n\nexport type RpcMethod =\n  | \"personal_sign\"\n  | \"eth_sendTransaction\"\n  | \"eth_accounts\"\n  | \"eth_requestAccounts\"\n  | \"eth_call\"\n  | \"eth_getBalance\"\n  | \"eth_sendRawTransaction\"\n  | \"eth_sign\"\n  | \"eth_signTransaction\"\n  | \"eth_signTypedData\"\n  | \"eth_signTypedData_v3\"\n  | \"eth_signTypedData_v4\"\n  | \"wallet_switchEthereumChain\"\n  | \"wallet_addEthereumChain\"\n  | \"wallet_getPermissions\"\n  | \"wallet_requestPermissions\"\n  | \"wallet_registerOnboarding\"\n  | \"wallet_watchAsset\"\n  | \"wallet_scanQRCode\"\n  | \"wallet_sendCalls\"\n  | \"wallet_getCapabilities\"\n  | \"wallet_getCallsStatus\"\n  | \"wallet_showCallsStatus\";\n\nexport type RpcEvent = \"accountsChanged\" | \"chainChanged\" | \"message\" | \"disconnect\" | \"connect\";\n\nexport interface EthereumRpcMap {\n  [chainId: string]: string;\n}\n\nexport interface SessionEvent {\n  event: { name: string; data: any };\n  chainId: string;\n}\n\nexport interface EthereumRpcConfig {\n  chains: string[];\n  optionalChains: string[];\n  methods: string[];\n  optionalMethods?: string[];\n  /**\n   * @description Events that the wallet MUST support or the connection will be rejected\n   */\n  events: string[];\n  optionalEvents?: string[];\n  rpcMap: EthereumRpcMap;\n  projectId: string;\n  metadata?: Metadata;\n  showQrModal: boolean;\n  qrModalOptions?: QrModalOptions;\n}\nexport interface ConnectOps {\n  chains?: number[];\n  optionalChains?: number[];\n  rpcMap?: EthereumRpcMap;\n  pairingTopic?: string;\n  scopedProperties?: unknown;\n}\n\nexport type AuthenticateParams = {\n  chains?: number[];\n} & Omit<AuthTypes.SessionAuthenticateParams, \"chains\">;\n\nexport interface IEthereumProvider extends IProvider {\n  connect(opts?: ConnectOps | undefined): Promise<void>;\n}\n\nexport function getRpcUrl(chainId: string, rpc: EthereumRpcConfig): string | undefined {\n  let rpcUrl: string | undefined;\n  if (rpc.rpcMap) {\n    rpcUrl = rpc.rpcMap[getEthereumChainId([chainId])];\n  }\n  return rpcUrl;\n}\n\nexport function getEthereumChainId(chains: string[]): number {\n  return Number(chains[0].split(\":\")[1]);\n}\n\nexport function toHexChainId(chainId: number): string {\n  return `0x${chainId.toString(16)}`;\n}\n\nexport type NamespacesParams = {\n  chains: EthereumRpcConfig[\"chains\"];\n  optionalChains: EthereumRpcConfig[\"optionalChains\"];\n  methods?: EthereumRpcConfig[\"methods\"];\n  optionalMethods?: EthereumRpcConfig[\"methods\"];\n  events?: EthereumRpcConfig[\"events\"];\n  rpcMap: EthereumRpcConfig[\"rpcMap\"];\n  optionalEvents?: EthereumRpcConfig[\"events\"];\n};\n\nexport function buildNamespaces(params: NamespacesParams): {\n  required?: Namespace;\n  optional?: Namespace;\n} {\n  const { chains, optionalChains, methods, optionalMethods, events, optionalEvents, rpcMap } =\n    params;\n  if (!isValidArray(chains)) {\n    throw new Error(\"Invalid chains\");\n  }\n\n  const required: Namespace = {\n    chains,\n    methods: methods || REQUIRED_METHODS,\n    events: events || REQUIRED_EVENTS,\n    rpcMap: {\n      ...(chains.length\n        ? { [getEthereumChainId(chains)]: rpcMap[getEthereumChainId(chains)] }\n        : {}),\n    },\n  };\n\n  // make a list of events and methods that require additional permissions\n  // so we know if we should to include the required chains in the optional namespace\n  const eventsRequiringPermissions = events?.filter((event) => !REQUIRED_EVENTS.includes(event));\n  const methodsRequiringPermissions = methods?.filter((event) => !REQUIRED_METHODS.includes(event));\n\n  if (\n    !optionalChains &&\n    !optionalEvents &&\n    !optionalMethods &&\n    !eventsRequiringPermissions?.length &&\n    !methodsRequiringPermissions?.length\n  ) {\n    return { required: chains.length ? required : undefined };\n  }\n\n  /*\n   * decides whether or not to include the required chains in the optional namespace\n   * use case: if there is a single chain as required but additional methods/events as optional\n   */\n  const shouldIncludeRequiredChains =\n    (eventsRequiringPermissions?.length && methodsRequiringPermissions?.length) || !optionalChains;\n\n  const optional: Namespace = {\n    chains: [\n      ...new Set(\n        shouldIncludeRequiredChains ? required.chains.concat(optionalChains || []) : optionalChains,\n      ),\n    ],\n    methods: [\n      ...new Set(\n        required.methods.concat(optionalMethods?.length ? optionalMethods : OPTIONAL_METHODS),\n      ),\n    ],\n    events: [\n      ...new Set(required.events.concat(optionalEvents?.length ? optionalEvents : OPTIONAL_EVENTS)),\n    ],\n    rpcMap,\n  };\n\n  return {\n    required: chains.length ? required : undefined,\n    optional: optionalChains.length ? optional : undefined,\n  };\n}\n\n// helper type to force setting at least one value in an array\ntype ArrayOneOrMore<T> = {\n  0: T;\n} & Array<T>;\n\n/**\n * @param {number[]} chains - The Chains your app intents to use and the peer MUST support. If the peer does not support these chains, the connection will be rejected.\n * @param {number[]} optionalChains - The Chains your app MAY attempt to use and the peer MAY support. If the peer does not support these chains, the connection will still be established.\n * @description either chains or optionalChains must be provided\n */\nexport type ChainsProps =\n  | {\n      chains: ArrayOneOrMore<number>;\n      optionalChains?: number[];\n    }\n  | {\n      chains?: number[];\n      optionalChains: ArrayOneOrMore<number>;\n    };\n\nexport type EthereumProviderOptions = {\n  projectId: string;\n  /**\n   * @note Methods that your app intents to use and the peer MUST support. If the peer does not support these methods, the connection will be rejected.\n   * @default [\"eth_sendTransaction\", \"personal_sign\"]\n   */\n  methods?: string[];\n  /**\n   * @note Methods that your app MAY attempt to use and the peer MAY support. If the peer does not support these methods, the connection will still be established.\n   */\n  optionalMethods?: string[];\n  events?: string[];\n  optionalEvents?: string[];\n  rpcMap?: EthereumRpcMap;\n  metadata?: Metadata;\n  showQrModal: boolean;\n  qrModalOptions?: QrModalOptions;\n  disableProviderPing?: boolean;\n  relayUrl?: string;\n  storageOptions?: KeyValueStorageOptions;\n} & ChainsProps &\n  UniversalProviderOpts;\n\nexport class EthereumProvider implements IEthereumProvider {\n  public events = new EventEmitter();\n  public namespace = \"eip155\";\n  public accounts: string[] = [];\n  public signer: InstanceType<typeof UniversalProvider>;\n  public chainId = 1;\n  public modal?: any;\n\n  protected rpc: EthereumRpcConfig;\n  protected readonly STORAGE_KEY = STORAGE_KEY;\n\n  constructor() {\n    // assigned during initialize\n    this.signer = {} as InstanceType<typeof UniversalProvider>;\n    this.rpc = {} as EthereumRpcConfig;\n  }\n\n  static async init(opts: EthereumProviderOptions): Promise<EthereumProvider> {\n    const provider = new EthereumProvider();\n    await provider.initialize(opts);\n    return provider;\n  }\n\n  public async request<T = unknown>(args: RequestArguments, expiry?: number): Promise<T> {\n    return await this.signer.request(args, this.formatChainId(this.chainId), expiry);\n  }\n\n  public sendAsync(\n    args: RequestArguments,\n    callback: (error: Error | null, response: JsonRpcResult) => void,\n    expiry?: number,\n  ): void {\n    this.signer.sendAsync(args, callback, this.formatChainId(this.chainId), expiry);\n  }\n\n  get connected(): boolean {\n    if (!this.signer.client) return false;\n    return this.signer.client.core.relayer.connected;\n  }\n\n  get connecting(): boolean {\n    if (!this.signer.client) return false;\n    return this.signer.client.core.relayer.connecting;\n  }\n\n  public async enable(): Promise<ProviderAccounts> {\n    if (!this.session) await this.connect();\n    const accounts = await this.request({ method: \"eth_requestAccounts\" });\n    return accounts as ProviderAccounts;\n  }\n\n  public async connect(opts?: ConnectOps): Promise<void> {\n    if (!this.signer.client) {\n      throw new Error(\"Provider not initialized. Call init() first\");\n    }\n\n    this.loadConnectOpts(opts);\n    const { required, optional } = buildNamespaces(this.rpc);\n    try {\n      const session = await new Promise<SessionTypes.Struct | undefined>(\n        async (resolve, reject) => {\n          if (this.rpc.showQrModal) {\n            this.modal?.subscribeModal((state: { open: boolean }) => {\n              // the modal was closed so reject the promise\n              if (!state.open && !this.signer.session) {\n                this.signer.abortPairingAttempt();\n                reject(new Error(\"Connection request reset. Please try again.\"));\n              }\n            });\n          }\n          const scopedProperties = opts?.scopedProperties\n            ? { [this.namespace]: opts.scopedProperties }\n            : undefined;\n\n          await this.signer\n            .connect({\n              namespaces: {\n                ...(required && {\n                  [this.namespace]: required,\n                }),\n              },\n              ...(optional && {\n                optionalNamespaces: {\n                  [this.namespace]: optional,\n                },\n              }),\n              pairingTopic: opts?.pairingTopic,\n              scopedProperties,\n            })\n            .then((session?: SessionTypes.Struct) => {\n              resolve(session);\n            })\n            .catch((error: Error) => {\n              reject(new Error(error.message));\n            });\n        },\n      );\n      if (!session) return;\n\n      const accounts = getAccountsFromNamespaces(session.namespaces, [this.namespace]);\n      // if no required chains are set, use the approved accounts to fetch chainIds\n      this.setChainIds(this.rpc.chains.length ? this.rpc.chains : accounts);\n      this.setAccounts(accounts);\n      this.events.emit(\"connect\", { chainId: toHexChainId(this.chainId) });\n    } catch (error) {\n      this.signer.logger.error(error);\n      throw error;\n    } finally {\n      if (this.modal) this.modal.closeModal();\n    }\n  }\n\n  public async authenticate(\n    params: AuthenticateParams,\n    walletUniversalLink?: string,\n  ): Promise<AuthTypes.AuthenticateResponseResult | undefined> {\n    if (!this.signer.client) {\n      throw new Error(\"Provider not initialized. Call init() first\");\n    }\n\n    this.loadConnectOpts({\n      chains: params?.chains,\n    });\n\n    try {\n      const result = await new Promise<AuthTypes.AuthenticateResponseResult>(\n        async (resolve, reject) => {\n          if (this.rpc.showQrModal) {\n            this.modal?.subscribeModal((state: { open: boolean }) => {\n              // the modal was closed so reject the promise\n              if (!state.open && !this.signer.session) {\n                this.signer.abortPairingAttempt();\n                reject(new Error(\"Connection request reset. Please try again.\"));\n              }\n            });\n          }\n          await this.signer\n            .authenticate(\n              {\n                ...params,\n                chains: this.rpc.chains,\n              },\n              walletUniversalLink,\n            )\n            .then((result: AuthTypes.AuthenticateResponseResult) => {\n              resolve(result);\n            })\n            .catch((error: Error) => {\n              reject(new Error(error.message));\n            });\n        },\n      );\n\n      const session = result.session;\n      if (session) {\n        const accounts = getAccountsFromNamespaces(session.namespaces, [this.namespace]);\n        // if no required chains are set, use the approved accounts to fetch chainIds as both contain <namespace>:<chainId>\n        this.setChainIds(this.rpc.chains.length ? this.rpc.chains : accounts);\n        this.setAccounts(accounts);\n        this.events.emit(\"connect\", { chainId: toHexChainId(this.chainId) });\n      }\n      return result;\n    } catch (error) {\n      this.signer.logger.error(error);\n      throw error;\n    } finally {\n      if (this.modal) this.modal.closeModal();\n    }\n  }\n\n  public async disconnect(): Promise<void> {\n    if (this.session) {\n      await this.signer.disconnect();\n    }\n    this.reset();\n  }\n\n  public on: IEthereumProviderEvents[\"on\"] = (event, listener) => {\n    this.events.on(event, listener);\n    return this;\n  };\n\n  public once: IEthereumProviderEvents[\"once\"] = (event, listener) => {\n    this.events.once(event, listener);\n    return this;\n  };\n\n  public removeListener: IEthereumProviderEvents[\"removeListener\"] = (event, listener) => {\n    this.events.removeListener(event, listener);\n    return this;\n  };\n\n  public off: IEthereumProviderEvents[\"off\"] = (event, listener) => {\n    this.events.off(event, listener);\n    return this;\n  };\n\n  get isWalletConnect() {\n    return true;\n  }\n\n  get session() {\n    return this.signer.session;\n  }\n\n  // ---------- Protected --------------------------------------------- //\n\n  protected registerEventListeners() {\n    this.signer.on(\"session_event\", (payload: SignClientTypes.EventArguments[\"session_event\"]) => {\n      const { params } = payload;\n      const { event } = params;\n      if (event.name === \"accountsChanged\") {\n        this.accounts = this.parseAccounts(event.data);\n        this.events.emit(\"accountsChanged\", this.accounts);\n      } else if (event.name === \"chainChanged\") {\n        this.setChainId(this.formatChainId(event.data));\n      } else {\n        this.events.emit(event.name as any, event.data);\n      }\n      this.events.emit(\"session_event\", payload);\n    });\n\n    this.signer.on(\"accountsChanged\", (accounts: string[]) => {\n      this.accounts = this.parseAccounts(accounts);\n      this.events.emit(\"accountsChanged\", this.accounts);\n    });\n\n    this.signer.on(\"chainChanged\", (chainId: string) => {\n      const chain = parseInt(chainId);\n      this.chainId = chain;\n      this.events.emit(\"chainChanged\", toHexChainId(this.chainId));\n      this.persist();\n    });\n\n    this.signer.on(\n      \"session_update\",\n      (payload: SignClientTypes.EventArguments[\"session_update\"]) => {\n        this.events.emit(\"session_update\", payload);\n      },\n    );\n\n    this.signer.on(\n      \"session_delete\",\n      (payload: SignClientTypes.EventArguments[\"session_delete\"]) => {\n        this.reset();\n        this.events.emit(\"session_delete\", payload);\n        this.events.emit(\"disconnect\", {\n          ...getSdkError(\"USER_DISCONNECTED\"),\n          data: payload.topic,\n          name: \"USER_DISCONNECTED\",\n        });\n      },\n    );\n\n    this.signer.on(\"display_uri\", (uri: string) => {\n      if (this.rpc.showQrModal) {\n        // to refresh the QR we have to close the modal and open it again\n        // until proper API is provided by walletconnect modal\n        this.modal?.closeModal();\n        this.modal?.openModal({ uri });\n      }\n      this.events.emit(\"display_uri\", uri);\n    });\n  }\n\n  protected switchEthereumChain(chainId: number): void {\n    this.request({\n      method: \"wallet_switchEthereumChain\",\n      params: [{ chainId: chainId.toString(16) }],\n    });\n  }\n\n  protected isCompatibleChainId(chainId: string): boolean {\n    return typeof chainId === \"string\" ? chainId.startsWith(`${this.namespace}:`) : false;\n  }\n\n  protected formatChainId(chainId: number): string {\n    return `${this.namespace}:${chainId}`;\n  }\n\n  protected parseChainId(chainId: string): number {\n    return Number(chainId.split(\":\")[1]);\n  }\n\n  protected setChainIds(chains: string[]) {\n    const compatible = chains.filter((x) => this.isCompatibleChainId(x));\n    const chainIds = compatible.map((c) => this.parseChainId(c));\n    if (chainIds.length) {\n      this.chainId = chainIds[0];\n      this.events.emit(\"chainChanged\", toHexChainId(this.chainId));\n      this.persist();\n    }\n  }\n\n  protected setChainId(chain: string) {\n    if (this.isCompatibleChainId(chain)) {\n      const chainId = this.parseChainId(chain);\n      this.chainId = chainId;\n      this.switchEthereumChain(chainId);\n    }\n  }\n\n  protected parseAccountId(account: string): { chainId: string; address: string } {\n    const [namespace, reference, address] = account.split(\":\");\n    const chainId = `${namespace}:${reference}`;\n    return { chainId, address };\n  }\n\n  protected setAccounts(accounts: string[]) {\n    this.accounts = accounts\n      .filter((x) => this.parseChainId(this.parseAccountId(x).chainId) === this.chainId)\n      .map((x) => this.parseAccountId(x).address);\n    this.events.emit(\"accountsChanged\", this.accounts);\n  }\n\n  protected getRpcConfig(opts: EthereumProviderOptions): EthereumRpcConfig {\n    const requiredChains = opts?.chains ?? [];\n    const optionalChains = opts?.optionalChains ?? [];\n    const allChains = requiredChains.concat(optionalChains);\n    if (!allChains.length)\n      throw new Error(\"No chains specified in either `chains` or `optionalChains`\");\n    const requiredMethods = requiredChains.length ? opts?.methods || REQUIRED_METHODS : [];\n    const requiredEvents = requiredChains.length ? opts?.events || REQUIRED_EVENTS : [];\n    const optionalMethods = opts?.optionalMethods || [];\n    const optionalEvents = opts?.optionalEvents || [];\n    const rpcMap = opts?.rpcMap || this.buildRpcMap(allChains, opts.projectId);\n    const qrModalOptions = opts?.qrModalOptions || undefined;\n    return {\n      chains: requiredChains?.map((chain) => this.formatChainId(chain)),\n      optionalChains: optionalChains.map((chain) => this.formatChainId(chain)),\n      methods: requiredMethods,\n      events: requiredEvents,\n      optionalMethods,\n      optionalEvents,\n      rpcMap,\n      showQrModal: Boolean(opts?.showQrModal),\n      qrModalOptions,\n      projectId: opts.projectId,\n      metadata: opts.metadata,\n    };\n  }\n\n  protected buildRpcMap(chains: number[], projectId: string): EthereumRpcMap {\n    const map: EthereumRpcMap = {};\n    chains.forEach((chain) => {\n      map[chain] = this.getRpcUrl(chain, projectId);\n    });\n    return map;\n  }\n\n  protected async initialize(opts: EthereumProviderOptions) {\n    this.rpc = this.getRpcConfig(opts);\n\n    this.chainId = this.rpc.chains.length\n      ? getEthereumChainId(this.rpc.chains)\n      : getEthereumChainId(this.rpc.optionalChains);\n    this.signer = await UniversalProvider.init({\n      projectId: this.rpc.projectId,\n      metadata: this.rpc.metadata,\n      disableProviderPing: opts.disableProviderPing,\n      relayUrl: opts.relayUrl,\n      storage: opts.storage,\n      storageOptions: opts.storageOptions,\n      customStoragePrefix: opts.customStoragePrefix,\n      telemetryEnabled: opts.telemetryEnabled,\n      logger: opts.logger,\n    });\n    this.registerEventListeners();\n    await this.loadPersistedSession();\n    if (this.rpc.showQrModal) {\n      let WalletConnectModalClass;\n      try {\n        const { WalletConnectModal } = await import(\"@walletconnect/modal\");\n        WalletConnectModalClass = WalletConnectModal;\n      } catch {\n        throw new Error(\"To use QR modal, please install @walletconnect/modal package\");\n      }\n      if (WalletConnectModalClass) {\n        try {\n          this.modal = new WalletConnectModalClass({\n            projectId: this.rpc.projectId,\n            ...this.rpc.qrModalOptions,\n          });\n        } catch (e) {\n          this.signer.logger.error(e);\n          throw new Error(\"Could not generate WalletConnectModal Instance\");\n        }\n      }\n    }\n  }\n\n  protected loadConnectOpts(opts?: ConnectOps) {\n    if (!opts) return;\n    const { chains, optionalChains, rpcMap } = opts;\n    if (chains && isValidArray(chains)) {\n      this.rpc.chains = chains.map((chain) => this.formatChainId(chain));\n      chains.forEach((chain) => {\n        this.rpc.rpcMap[chain] = rpcMap?.[chain] || this.getRpcUrl(chain);\n      });\n    }\n    if (optionalChains && isValidArray(optionalChains)) {\n      this.rpc.optionalChains = [];\n      this.rpc.optionalChains = optionalChains?.map((chain) => this.formatChainId(chain));\n      optionalChains.forEach((chain) => {\n        this.rpc.rpcMap[chain] = rpcMap?.[chain] || this.getRpcUrl(chain);\n      });\n    }\n  }\n\n  protected getRpcUrl(chainId: number, projectId?: string): string {\n    const providedRpc = this.rpc.rpcMap?.[chainId];\n    return (\n      providedRpc ||\n      `${RPC_URL}?chainId=eip155:${chainId}&projectId=${projectId || this.rpc.projectId}`\n    );\n  }\n\n  protected async loadPersistedSession() {\n    if (!this.session) return;\n    try {\n      const chainId = await this.signer.client.core.storage.getItem(`${this.STORAGE_KEY}/chainId`);\n\n      // cater to both inline & nested namespace formats\n      const namespace = this.session.namespaces[`${this.namespace}:${chainId}`]\n        ? this.session.namespaces[`${this.namespace}:${chainId}`]\n        : this.session.namespaces[this.namespace];\n\n      this.setChainIds(chainId ? [this.formatChainId(chainId)] : namespace?.accounts);\n      this.setAccounts(namespace?.accounts);\n    } catch (error) {\n      this.signer.logger.error(\"Failed to load persisted session, clearing state...\");\n      this.signer.logger.error(error);\n      await this.disconnect().catch((error) => this.signer.logger.warn(error));\n    }\n  }\n\n  protected reset() {\n    this.chainId = 1;\n    this.accounts = [];\n  }\n\n  protected persist() {\n    if (!this.session) return;\n    this.signer.client.core.storage.setItem(`${this.STORAGE_KEY}/chainId`, this.chainId);\n  }\n\n  protected parseAccounts(payload: string | string[]): string[] {\n    if (typeof payload === \"string\" || payload instanceof String) {\n      return [this.parseAccount(payload)];\n    }\n    return payload.map((account: string) => this.parseAccount(account));\n  }\n\n  protected parseAccount = (payload: any): string => {\n    return this.isCompatibleChainId(payload) ? this.parseAccountId(payload).address : payload;\n  };\n}\n\nexport default EthereumProvider;\n","import { EthereumProvider as Provider } from \"./EthereumProvider\";\nexport const EthereumProvider = Provider;\nexport type { EthereumProviderOptions, RpcEvent, RpcMethod } from \"./EthereumProvider\";\nexport * from \"./constants/rpc\";\nexport default Provider;\n"],"mappings":"","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}