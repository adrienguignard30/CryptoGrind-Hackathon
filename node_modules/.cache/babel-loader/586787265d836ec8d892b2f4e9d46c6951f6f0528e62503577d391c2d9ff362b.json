{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.waitForTransactionReceipt = waitForTransactionReceipt;\nconst block_js_1 = require(\"../../errors/block.js\");\nconst transaction_js_1 = require(\"../../errors/transaction.js\");\nconst getAction_js_1 = require(\"../../utils/getAction.js\");\nconst observe_js_1 = require(\"../../utils/observe.js\");\nconst withResolvers_js_1 = require(\"../../utils/promise/withResolvers.js\");\nconst withRetry_js_1 = require(\"../../utils/promise/withRetry.js\");\nconst stringify_js_1 = require(\"../../utils/stringify.js\");\nconst getBlock_js_1 = require(\"./getBlock.js\");\nconst getTransaction_js_1 = require(\"./getTransaction.js\");\nconst getTransactionReceipt_js_1 = require(\"./getTransactionReceipt.js\");\nconst watchBlockNumber_js_1 = require(\"./watchBlockNumber.js\");\nasync function waitForTransactionReceipt(client, {\n  confirmations = 1,\n  hash,\n  onReplaced,\n  pollingInterval = client.pollingInterval,\n  retryCount = 6,\n  retryDelay = ({\n    count\n  }) => ~~(1 << count) * 200,\n  timeout = 180_000\n}) {\n  const observerId = (0, stringify_js_1.stringify)(['waitForTransactionReceipt', client.uid, hash]);\n  let transaction;\n  let replacedTransaction;\n  let receipt;\n  let retrying = false;\n  const {\n    promise,\n    resolve,\n    reject\n  } = (0, withResolvers_js_1.withResolvers)();\n  const timer = timeout ? setTimeout(() => reject(new transaction_js_1.WaitForTransactionReceiptTimeoutError({\n    hash\n  })), timeout) : undefined;\n  const _unobserve = (0, observe_js_1.observe)(observerId, {\n    onReplaced,\n    resolve,\n    reject\n  }, emit => {\n    const _unwatch = (0, getAction_js_1.getAction)(client, watchBlockNumber_js_1.watchBlockNumber, 'watchBlockNumber')({\n      emitMissed: true,\n      emitOnBegin: true,\n      poll: true,\n      pollingInterval,\n      async onBlockNumber(blockNumber_) {\n        const done = fn => {\n          clearTimeout(timer);\n          _unwatch();\n          fn();\n          _unobserve();\n        };\n        let blockNumber = blockNumber_;\n        if (retrying) return;\n        try {\n          if (receipt) {\n            if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n            done(() => emit.resolve(receipt));\n            return;\n          }\n          if (!transaction) {\n            retrying = true;\n            await (0, withRetry_js_1.withRetry)(async () => {\n              transaction = await (0, getAction_js_1.getAction)(client, getTransaction_js_1.getTransaction, 'getTransaction')({\n                hash\n              });\n              if (transaction.blockNumber) blockNumber = transaction.blockNumber;\n            }, {\n              delay: retryDelay,\n              retryCount\n            });\n            retrying = false;\n          }\n          receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({\n            hash\n          });\n          if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n          done(() => emit.resolve(receipt));\n        } catch (err) {\n          if (err instanceof transaction_js_1.TransactionNotFoundError || err instanceof transaction_js_1.TransactionReceiptNotFoundError) {\n            if (!transaction) {\n              retrying = false;\n              return;\n            }\n            try {\n              replacedTransaction = transaction;\n              retrying = true;\n              const block = await (0, withRetry_js_1.withRetry)(() => (0, getAction_js_1.getAction)(client, getBlock_js_1.getBlock, 'getBlock')({\n                blockNumber,\n                includeTransactions: true\n              }), {\n                delay: retryDelay,\n                retryCount,\n                shouldRetry: ({\n                  error\n                }) => error instanceof block_js_1.BlockNotFoundError\n              });\n              retrying = false;\n              const replacementTransaction = block.transactions.find(({\n                from,\n                nonce\n              }) => from === replacedTransaction.from && nonce === replacedTransaction.nonce);\n              if (!replacementTransaction) return;\n              receipt = await (0, getAction_js_1.getAction)(client, getTransactionReceipt_js_1.getTransactionReceipt, 'getTransactionReceipt')({\n                hash: replacementTransaction.hash\n              });\n              if (confirmations > 1 && (!receipt.blockNumber || blockNumber - receipt.blockNumber + 1n < confirmations)) return;\n              let reason = 'replaced';\n              if (replacementTransaction.to === replacedTransaction.to && replacementTransaction.value === replacedTransaction.value && replacementTransaction.input === replacedTransaction.input) {\n                reason = 'repriced';\n              } else if (replacementTransaction.from === replacementTransaction.to && replacementTransaction.value === 0n) {\n                reason = 'cancelled';\n              }\n              done(() => {\n                emit.onReplaced?.({\n                  reason,\n                  replacedTransaction: replacedTransaction,\n                  transaction: replacementTransaction,\n                  transactionReceipt: receipt\n                });\n                emit.resolve(receipt);\n              });\n            } catch (err_) {\n              done(() => emit.reject(err_));\n            }\n          } else {\n            done(() => emit.reject(err));\n          }\n        }\n      }\n    });\n  });\n  return promise;\n}","map":{"version":3,"names":["exports","waitForTransactionReceipt","block_js_1","require","transaction_js_1","getAction_js_1","observe_js_1","withResolvers_js_1","withRetry_js_1","stringify_js_1","getBlock_js_1","getTransaction_js_1","getTransactionReceipt_js_1","watchBlockNumber_js_1","client","confirmations","hash","onReplaced","pollingInterval","retryCount","retryDelay","count","timeout","observerId","stringify","uid","transaction","replacedTransaction","receipt","retrying","promise","resolve","reject","withResolvers","timer","setTimeout","WaitForTransactionReceiptTimeoutError","undefined","_unobserve","observe","emit","_unwatch","getAction","watchBlockNumber","emitMissed","emitOnBegin","poll","onBlockNumber","blockNumber_","done","fn","clearTimeout","blockNumber","withRetry","getTransaction","delay","getTransactionReceipt","err","TransactionNotFoundError","TransactionReceiptNotFoundError","block","getBlock","includeTransactions","shouldRetry","error","BlockNotFoundError","replacementTransaction","transactions","find","from","nonce","reason","to","value","input","transactionReceipt","err_"],"sources":["C:\\Users\\Adrien\\Desktop\\CryptoGrind - Copie\\client\\node_modules\\viem\\actions\\public\\waitForTransactionReceipt.ts"],"sourcesContent":["import type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { BlockNotFoundError } from '../../errors/block.js'\nimport {\n  TransactionNotFoundError,\n  TransactionReceiptNotFoundError,\n  WaitForTransactionReceiptTimeoutError,\n  type WaitForTransactionReceiptTimeoutErrorType,\n} from '../../errors/transaction.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hash } from '../../types/misc.js'\nimport type { Transaction } from '../../types/transaction.js'\nimport { getAction } from '../../utils/getAction.js'\nimport { type ObserveErrorType, observe } from '../../utils/observe.js'\nimport { withResolvers } from '../../utils/promise/withResolvers.js'\nimport {\n  type WithRetryParameters,\n  withRetry,\n} from '../../utils/promise/withRetry.js'\nimport { stringify } from '../../utils/stringify.js'\n\nimport { type GetBlockErrorType, getBlock } from './getBlock.js'\nimport {\n  type GetTransactionErrorType,\n  type GetTransactionReturnType,\n  getTransaction,\n} from './getTransaction.js'\nimport {\n  type GetTransactionReceiptErrorType,\n  type GetTransactionReceiptReturnType,\n  getTransactionReceipt,\n} from './getTransactionReceipt.js'\nimport {\n  type WatchBlockNumberErrorType,\n  watchBlockNumber,\n} from './watchBlockNumber.js'\n\nexport type ReplacementReason = 'cancelled' | 'replaced' | 'repriced'\nexport type ReplacementReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  reason: ReplacementReason\n  replacedTransaction: Transaction\n  transaction: Transaction\n  transactionReceipt: GetTransactionReceiptReturnType<chain>\n}\n\nexport type WaitForTransactionReceiptReturnType<\n  chain extends Chain | undefined = Chain | undefined,\n> = GetTransactionReceiptReturnType<chain>\n\nexport type WaitForTransactionReceiptParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = {\n  /**\n   * The number of confirmations (blocks that have passed) to wait before resolving.\n   * @default 1\n   */\n  confirmations?: number | undefined\n  /** The hash of the transaction. */\n  hash: Hash\n  /** Optional callback to emit if the transaction has been replaced. */\n  onReplaced?: ((response: ReplacementReturnType<chain>) => void) | undefined\n  /**\n   * Polling frequency (in ms). Defaults to the client's pollingInterval config.\n   * @default client.pollingInterval\n   */\n  pollingInterval?: number | undefined\n  /**\n   * Number of times to retry if the transaction or block is not found.\n   * @default 6 (exponential backoff)\n   */\n  retryCount?: WithRetryParameters['retryCount'] | undefined\n  /**\n   * Time to wait (in ms) between retries.\n   * @default `({ count }) => ~~(1 << count) * 200` (exponential backoff)\n   */\n  retryDelay?: WithRetryParameters['delay'] | undefined\n  /**\n   * Optional timeout (in milliseconds) to wait before stopping polling.\n   * @default 180_000\n   */\n  timeout?: number | undefined\n}\n\nexport type WaitForTransactionReceiptErrorType =\n  | ObserveErrorType\n  | GetBlockErrorType\n  | GetTransactionErrorType\n  | GetTransactionReceiptErrorType\n  | WatchBlockNumberErrorType\n  | WaitForTransactionReceiptTimeoutErrorType\n  | ErrorType\n\n/**\n * Waits for the [Transaction](https://viem.sh/docs/glossary/terms#transaction) to be included on a [Block](https://viem.sh/docs/glossary/terms#block) (one confirmation), and then returns the [Transaction Receipt](https://viem.sh/docs/glossary/terms#transaction-receipt).\n *\n * - Docs: https://viem.sh/docs/actions/public/waitForTransactionReceipt\n * - Example: https://stackblitz.com/github/wevm/viem/tree/main/examples/transactions_sending-transactions\n * - JSON-RPC Methods:\n *   - Polls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt) on each block until it has been processed.\n *   - If a Transaction has been replaced:\n *     - Calls [`eth_getBlockByNumber`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getblockbynumber) and extracts the transactions\n *     - Checks if one of the Transactions is a replacement\n *     - If so, calls [`eth_getTransactionReceipt`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_getTransactionReceipt).\n *\n * The `waitForTransactionReceipt` action additionally supports Replacement detection (e.g. sped up Transactions).\n *\n * Transactions can be replaced when a user modifies their transaction in their wallet (to speed up or cancel). Transactions are replaced when they are sent from the same nonce.\n *\n * There are 3 types of Transaction Replacement reasons:\n *\n * - `repriced`: The gas price has been modified (e.g. different `maxFeePerGas`)\n * - `cancelled`: The Transaction has been cancelled (e.g. `value === 0n`)\n * - `replaced`: The Transaction has been replaced (e.g. different `value` or `data`)\n *\n * @param client - Client to use\n * @param parameters - {@link WaitForTransactionReceiptParameters}\n * @returns The transaction receipt. {@link WaitForTransactionReceiptReturnType}\n *\n * @example\n * import { createPublicClient, waitForTransactionReceipt, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const transactionReceipt = await waitForTransactionReceipt(client, {\n *   hash: '0x4ca7ee652d57678f26e887c149ab0735f41de37bcad58c9f6d3ed5824f15b74d',\n * })\n */\nexport async function waitForTransactionReceipt<\n  chain extends Chain | undefined,\n>(\n  client: Client<Transport, chain>,\n  {\n    confirmations = 1,\n    hash,\n    onReplaced,\n    pollingInterval = client.pollingInterval,\n    retryCount = 6,\n    retryDelay = ({ count }) => ~~(1 << count) * 200, // exponential backoff\n    timeout = 180_000,\n  }: WaitForTransactionReceiptParameters<chain>,\n): Promise<WaitForTransactionReceiptReturnType<chain>> {\n  const observerId = stringify(['waitForTransactionReceipt', client.uid, hash])\n\n  let transaction: GetTransactionReturnType<chain> | undefined\n  let replacedTransaction: GetTransactionReturnType<chain> | undefined\n  let receipt: GetTransactionReceiptReturnType<chain>\n  let retrying = false\n\n  const { promise, resolve, reject } =\n    withResolvers<WaitForTransactionReceiptReturnType<chain>>()\n\n  const timer = timeout\n    ? setTimeout(\n        () => reject(new WaitForTransactionReceiptTimeoutError({ hash })),\n        timeout,\n      )\n    : undefined\n\n  const _unobserve = observe(\n    observerId,\n    { onReplaced, resolve, reject },\n    (emit) => {\n      const _unwatch = getAction(\n        client,\n        watchBlockNumber,\n        'watchBlockNumber',\n      )({\n        emitMissed: true,\n        emitOnBegin: true,\n        poll: true,\n        pollingInterval,\n        async onBlockNumber(blockNumber_) {\n          const done = (fn: () => void) => {\n            clearTimeout(timer)\n            _unwatch()\n            fn()\n            _unobserve()\n          }\n\n          let blockNumber = blockNumber_\n\n          if (retrying) return\n\n          try {\n            // If we already have a valid receipt, let's check if we have enough\n            // confirmations. If we do, then we can resolve.\n            if (receipt) {\n              if (\n                confirmations > 1 &&\n                (!receipt.blockNumber ||\n                  blockNumber - receipt.blockNumber + 1n < confirmations)\n              )\n                return\n\n              done(() => emit.resolve(receipt))\n              return\n            }\n\n            // Get the transaction to check if it's been replaced.\n            // We need to retry as some RPC Providers may be slow to sync\n            // up mined transactions.\n            if (!transaction) {\n              retrying = true\n              await withRetry(\n                async () => {\n                  transaction = (await getAction(\n                    client,\n                    getTransaction,\n                    'getTransaction',\n                  )({ hash })) as GetTransactionReturnType<chain>\n                  if (transaction.blockNumber)\n                    blockNumber = transaction.blockNumber\n                },\n                {\n                  delay: retryDelay,\n                  retryCount,\n                },\n              )\n              retrying = false\n            }\n\n            // Get the receipt to check if it's been processed.\n            receipt = await getAction(\n              client,\n              getTransactionReceipt,\n              'getTransactionReceipt',\n            )({ hash })\n\n            // Check if we have enough confirmations. If not, continue polling.\n            if (\n              confirmations > 1 &&\n              (!receipt.blockNumber ||\n                blockNumber - receipt.blockNumber + 1n < confirmations)\n            )\n              return\n\n            done(() => emit.resolve(receipt))\n          } catch (err) {\n            // If the receipt is not found, the transaction will be pending.\n            // We need to check if it has potentially been replaced.\n            if (\n              err instanceof TransactionNotFoundError ||\n              err instanceof TransactionReceiptNotFoundError\n            ) {\n              if (!transaction) {\n                retrying = false\n                return\n              }\n\n              try {\n                replacedTransaction = transaction\n\n                // Let's retrieve the transactions from the current block.\n                // We need to retry as some RPC Providers may be slow to sync\n                // up mined blocks.\n                retrying = true\n                const block = await withRetry(\n                  () =>\n                    getAction(\n                      client,\n                      getBlock,\n                      'getBlock',\n                    )({\n                      blockNumber,\n                      includeTransactions: true,\n                    }),\n                  {\n                    delay: retryDelay,\n                    retryCount,\n                    shouldRetry: ({ error }) =>\n                      error instanceof BlockNotFoundError,\n                  },\n                )\n                retrying = false\n\n                const replacementTransaction = (\n                  block.transactions as {} as Transaction[]\n                ).find(\n                  ({ from, nonce }) =>\n                    from === replacedTransaction!.from &&\n                    nonce === replacedTransaction!.nonce,\n                )\n\n                // If we couldn't find a replacement transaction, continue polling.\n                if (!replacementTransaction) return\n\n                // If we found a replacement transaction, return it's receipt.\n                receipt = await getAction(\n                  client,\n                  getTransactionReceipt,\n                  'getTransactionReceipt',\n                )({\n                  hash: replacementTransaction.hash,\n                })\n\n                // Check if we have enough confirmations. If not, continue polling.\n                if (\n                  confirmations > 1 &&\n                  (!receipt.blockNumber ||\n                    blockNumber - receipt.blockNumber + 1n < confirmations)\n                )\n                  return\n\n                let reason: ReplacementReason = 'replaced'\n                if (\n                  replacementTransaction.to === replacedTransaction.to &&\n                  replacementTransaction.value === replacedTransaction.value &&\n                  replacementTransaction.input === replacedTransaction.input\n                ) {\n                  reason = 'repriced'\n                } else if (\n                  replacementTransaction.from === replacementTransaction.to &&\n                  replacementTransaction.value === 0n\n                ) {\n                  reason = 'cancelled'\n                }\n\n                done(() => {\n                  emit.onReplaced?.({\n                    reason,\n                    replacedTransaction: replacedTransaction! as any,\n                    transaction: replacementTransaction,\n                    transactionReceipt: receipt,\n                  })\n                  emit.resolve(receipt)\n                })\n              } catch (err_) {\n                done(() => emit.reject(err_))\n              }\n            } else {\n              done(() => emit.reject(err))\n            }\n          }\n        },\n      })\n    },\n  )\n\n  return promise\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}