{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.call = call;\nexports.getRevertErrorData = getRevertErrorData;\nconst abitype_1 = require(\"abitype\");\nconst parseAccount_js_1 = require(\"../../accounts/utils/parseAccount.js\");\nconst abis_js_1 = require(\"../../constants/abis.js\");\nconst contract_js_1 = require(\"../../constants/contract.js\");\nconst contracts_js_1 = require(\"../../constants/contracts.js\");\nconst base_js_1 = require(\"../../errors/base.js\");\nconst chain_js_1 = require(\"../../errors/chain.js\");\nconst contract_js_2 = require(\"../../errors/contract.js\");\nconst decodeFunctionResult_js_1 = require(\"../../utils/abi/decodeFunctionResult.js\");\nconst encodeDeployData_js_1 = require(\"../../utils/abi/encodeDeployData.js\");\nconst encodeFunctionData_js_1 = require(\"../../utils/abi/encodeFunctionData.js\");\nconst getChainContractAddress_js_1 = require(\"../../utils/chain/getChainContractAddress.js\");\nconst toHex_js_1 = require(\"../../utils/encoding/toHex.js\");\nconst getCallError_js_1 = require(\"../../utils/errors/getCallError.js\");\nconst extract_js_1 = require(\"../../utils/formatters/extract.js\");\nconst transactionRequest_js_1 = require(\"../../utils/formatters/transactionRequest.js\");\nconst createBatchScheduler_js_1 = require(\"../../utils/promise/createBatchScheduler.js\");\nconst stateOverride_js_1 = require(\"../../utils/stateOverride.js\");\nconst assertRequest_js_1 = require(\"../../utils/transaction/assertRequest.js\");\nasync function call(client, args) {\n  const {\n    account: account_ = client.account,\n    batch = Boolean(client.batch?.multicall),\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    blobs,\n    code,\n    data: data_,\n    factory,\n    factoryData,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    stateOverride,\n    ...rest\n  } = args;\n  const account = account_ ? (0, parseAccount_js_1.parseAccount)(account_) : undefined;\n  if (code && (factory || factoryData)) throw new base_js_1.BaseError('Cannot provide both `code` & `factory`/`factoryData` as parameters.');\n  if (code && to) throw new base_js_1.BaseError('Cannot provide both `code` & `to` as parameters.');\n  const deploylessCallViaBytecode = code && data_;\n  const deploylessCallViaFactory = factory && factoryData && to && data_;\n  const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory;\n  const data = (() => {\n    if (deploylessCallViaBytecode) return toDeploylessCallViaBytecodeData({\n      code,\n      data: data_\n    });\n    if (deploylessCallViaFactory) return toDeploylessCallViaFactoryData({\n      data: data_,\n      factory,\n      factoryData,\n      to\n    });\n    return data_;\n  })();\n  try {\n    (0, assertRequest_js_1.assertRequest)(args);\n    const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;\n    const block = blockNumberHex || blockTag;\n    const rpcStateOverride = (0, stateOverride_js_1.serializeStateOverride)(stateOverride);\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format;\n    const format = chainFormat || transactionRequest_js_1.formatTransactionRequest;\n    const request = format({\n      ...(0, extract_js_1.extract)(rest, {\n        format: chainFormat\n      }),\n      from: account?.address,\n      accessList,\n      blobs,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to: deploylessCall ? undefined : to,\n      value\n    });\n    if (batch && shouldPerformMulticall({\n      request\n    }) && !rpcStateOverride) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag\n        });\n      } catch (err) {\n        if (!(err instanceof chain_js_1.ClientChainNotConfiguredError) && !(err instanceof chain_js_1.ChainDoesNotSupportContract)) throw err;\n      }\n    }\n    const response = await client.request({\n      method: 'eth_call',\n      params: rpcStateOverride ? [request, block, rpcStateOverride] : [request, block]\n    });\n    if (response === '0x') return {\n      data: undefined\n    };\n    return {\n      data: response\n    };\n  } catch (err) {\n    const data = getRevertErrorData(err);\n    const {\n      offchainLookup,\n      offchainLookupSignature\n    } = await Promise.resolve().then(() => require('../../utils/ccip.js'));\n    if (client.ccipRead !== false && data?.slice(0, 10) === offchainLookupSignature && to) return {\n      data: await offchainLookup(client, {\n        data,\n        to\n      })\n    };\n    if (deploylessCall && data?.slice(0, 10) === '0x101bb98d') throw new contract_js_2.CounterfactualDeploymentFailedError({\n      factory\n    });\n    throw (0, getCallError_js_1.getCallError)(err, {\n      ...args,\n      account,\n      chain: client.chain\n    });\n  }\n}\nfunction shouldPerformMulticall({\n  request\n}) {\n  const {\n    data,\n    to,\n    ...request_\n  } = request;\n  if (!data) return false;\n  if (data.startsWith(contract_js_1.aggregate3Signature)) return false;\n  if (!to) return false;\n  if (Object.values(request_).filter(x => typeof x !== 'undefined').length > 0) return false;\n  return true;\n}\nasync function scheduleMulticall(client, args) {\n  const {\n    batchSize = 1024,\n    wait = 0\n  } = typeof client.batch?.multicall === 'object' ? client.batch.multicall : {};\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    data,\n    multicallAddress: multicallAddress_,\n    to\n  } = args;\n  let multicallAddress = multicallAddress_;\n  if (!multicallAddress) {\n    if (!client.chain) throw new chain_js_1.ClientChainNotConfiguredError();\n    multicallAddress = (0, getChainContractAddress_js_1.getChainContractAddress)({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3'\n    });\n  }\n  const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;\n  const block = blockNumberHex || blockTag;\n  const {\n    schedule\n  } = (0, createBatchScheduler_js_1.createBatchScheduler)({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, {\n        data\n      }) => size + (data.length - 2), 0);\n      return size > batchSize * 2;\n    },\n    fn: async requests => {\n      const calls = requests.map(request => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to\n      }));\n      const calldata = (0, encodeFunctionData_js_1.encodeFunctionData)({\n        abi: abis_js_1.multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3'\n      });\n      const data = await client.request({\n        method: 'eth_call',\n        params: [{\n          data: calldata,\n          to: multicallAddress\n        }, block]\n      });\n      return (0, decodeFunctionResult_js_1.decodeFunctionResult)({\n        abi: abis_js_1.multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x'\n      });\n    }\n  });\n  const [{\n    returnData,\n    success\n  }] = await schedule({\n    data,\n    to\n  });\n  if (!success) throw new contract_js_2.RawContractError({\n    data: returnData\n  });\n  if (returnData === '0x') return {\n    data: undefined\n  };\n  return {\n    data: returnData\n  };\n}\nfunction toDeploylessCallViaBytecodeData(parameters) {\n  const {\n    code,\n    data\n  } = parameters;\n  return (0, encodeDeployData_js_1.encodeDeployData)({\n    abi: (0, abitype_1.parseAbi)(['constructor(bytes, bytes)']),\n    bytecode: contracts_js_1.deploylessCallViaBytecodeBytecode,\n    args: [code, data]\n  });\n}\nfunction toDeploylessCallViaFactoryData(parameters) {\n  const {\n    data,\n    factory,\n    factoryData,\n    to\n  } = parameters;\n  return (0, encodeDeployData_js_1.encodeDeployData)({\n    abi: (0, abitype_1.parseAbi)(['constructor(address, bytes, address, bytes)']),\n    bytecode: contracts_js_1.deploylessCallViaFactoryBytecode,\n    args: [to, data, factory, factoryData]\n  });\n}\nfunction getRevertErrorData(err) {\n  if (!(err instanceof base_js_1.BaseError)) return undefined;\n  const error = err.walk();\n  return typeof error?.data === 'object' ? error.data?.data : error.data;\n}","map":{"version":3,"names":["exports","call","getRevertErrorData","abitype_1","require","parseAccount_js_1","abis_js_1","contract_js_1","contracts_js_1","base_js_1","chain_js_1","contract_js_2","decodeFunctionResult_js_1","encodeDeployData_js_1","encodeFunctionData_js_1","getChainContractAddress_js_1","toHex_js_1","getCallError_js_1","extract_js_1","transactionRequest_js_1","createBatchScheduler_js_1","stateOverride_js_1","assertRequest_js_1","client","args","account","account_","batch","Boolean","multicall","blockNumber","blockTag","accessList","blobs","code","data","data_","factory","factoryData","gas","gasPrice","maxFeePerBlobGas","maxFeePerGas","maxPriorityFeePerGas","nonce","to","value","stateOverride","rest","parseAccount","undefined","BaseError","deploylessCallViaBytecode","deploylessCallViaFactory","deploylessCall","toDeploylessCallViaBytecodeData","toDeploylessCallViaFactoryData","assertRequest","blockNumberHex","numberToHex","block","rpcStateOverride","serializeStateOverride","chainFormat","chain","formatters","transactionRequest","format","formatTransactionRequest","request","extract","from","address","shouldPerformMulticall","scheduleMulticall","err","ClientChainNotConfiguredError","ChainDoesNotSupportContract","response","method","params","offchainLookup","offchainLookupSignature","Promise","resolve","then","ccipRead","slice","CounterfactualDeploymentFailedError","getCallError","request_","startsWith","aggregate3Signature","Object","values","filter","x","length","batchSize","wait","multicallAddress","multicallAddress_","getChainContractAddress","contract","schedule","createBatchScheduler","id","uid","shouldSplitBatch","size","reduce","fn","requests","calls","map","allowFailure","callData","target","calldata","encodeFunctionData","abi","multicall3Abi","functionName","decodeFunctionResult","returnData","success","RawContractError","parameters","encodeDeployData","parseAbi","bytecode","deploylessCallViaBytecodeBytecode","deploylessCallViaFactoryBytecode","error","walk"],"sources":["C:\\Users\\Adrien\\Desktop\\CryptoGrind - Copie\\client\\node_modules\\viem\\actions\\public\\call.ts"],"sourcesContent":["import { type Address, parseAbi } from 'abitype'\n\nimport type { Account } from '../../accounts/types.js'\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { multicall3Abi } from '../../constants/abis.js'\nimport { aggregate3Signature } from '../../constants/contract.js'\nimport {\n  deploylessCallViaBytecodeBytecode,\n  deploylessCallViaFactoryBytecode,\n} from '../../constants/contracts.js'\nimport { BaseError } from '../../errors/base.js'\nimport {\n  ChainDoesNotSupportContract,\n  ClientChainNotConfiguredError,\n} from '../../errors/chain.js'\nimport {\n  CounterfactualDeploymentFailedError,\n  RawContractError,\n  type RawContractErrorType,\n} from '../../errors/contract.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { BlockTag } from '../../types/block.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { RpcTransactionRequest } from '../../types/rpc.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial, UnionOmit } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeDeployDataErrorType,\n  encodeDeployData,\n} from '../../utils/abi/encodeDeployData.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport type { RequestErrorType } from '../../utils/buildRequest.js'\nimport {\n  type GetChainContractAddressErrorType,\n  getChainContractAddress,\n} from '../../utils/chain/getChainContractAddress.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport {\n  type GetCallErrorReturnType,\n  getCallError,\n} from '../../utils/errors/getCallError.js'\nimport { extract } from '../../utils/formatters/extract.js'\nimport {\n  type FormatTransactionRequestErrorType,\n  type FormattedTransactionRequest,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport {\n  type CreateBatchSchedulerErrorType,\n  createBatchScheduler,\n} from '../../utils/promise/createBatchScheduler.js'\nimport {\n  type SerializeStateOverrideErrorType,\n  serializeStateOverride,\n} from '../../utils/stateOverride.js'\nimport { assertRequest } from '../../utils/transaction/assertRequest.js'\nimport type {\n  AssertRequestErrorType,\n  AssertRequestParameters,\n} from '../../utils/transaction/assertRequest.js'\n\nexport type CallParameters<\n  chain extends Chain | undefined = Chain | undefined,\n> = UnionOmit<FormattedCall<chain>, 'from'> & {\n  /** Account attached to the call (msg.sender). */\n  account?: Account | Address | undefined\n  /** Whether or not to enable multicall batching on this call. */\n  batch?: boolean | undefined\n  /** Bytecode to perform the call on. */\n  code?: Hex | undefined\n  /** Contract deployment factory address (ie. Create2 factory, Smart Account factory, etc). */\n  factory?: Address | undefined\n  /** Calldata to execute on the factory to deploy the contract. */\n  factoryData?: Hex | undefined\n  /** State overrides for the call. */\n  stateOverride?: StateOverride | undefined\n} & (\n    | {\n        /** The balance of the account at a block number. */\n        blockNumber?: bigint | undefined\n        blockTag?: undefined\n      }\n    | {\n        blockNumber?: undefined\n        /**\n         * The balance of the account at a block tag.\n         * @default 'latest'\n         */\n        blockTag?: BlockTag | undefined\n      }\n  )\ntype FormattedCall<chain extends Chain | undefined = Chain | undefined> =\n  FormattedTransactionRequest<chain>\n\nexport type CallReturnType = { data: Hex | undefined }\n\nexport type CallErrorType = GetCallErrorReturnType<\n  | ParseAccountErrorType\n  | SerializeStateOverrideErrorType\n  | AssertRequestErrorType\n  | NumberToHexErrorType\n  | FormatTransactionRequestErrorType\n  | ScheduleMulticallErrorType\n  | RequestErrorType\n  | ToDeploylessCallViaBytecodeDataErrorType\n  | ToDeploylessCallViaFactoryDataErrorType\n>\n\n/**\n * Executes a new message call immediately without submitting a transaction to the network.\n *\n * - Docs: https://viem.sh/docs/actions/public/call\n * - JSON-RPC Methods: [`eth_call`](https://ethereum.org/en/developers/docs/apis/json-rpc/#eth_call)\n *\n * @param client - Client to use\n * @param parameters - {@link CallParameters}\n * @returns The call data. {@link CallReturnType}\n *\n * @example\n * import { createPublicClient, http } from 'viem'\n * import { mainnet } from 'viem/chains'\n * import { call } from 'viem/public'\n *\n * const client = createPublicClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n * const data = await call(client, {\n *   account: '0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266',\n *   data: '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2',\n *   to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n * })\n */\nexport async function call<chain extends Chain | undefined>(\n  client: Client<Transport, chain>,\n  args: CallParameters<chain>,\n): Promise<CallReturnType> {\n  const {\n    account: account_ = client.account,\n    batch = Boolean(client.batch?.multicall),\n    blockNumber,\n    blockTag = 'latest',\n    accessList,\n    blobs,\n    code,\n    data: data_,\n    factory,\n    factoryData,\n    gas,\n    gasPrice,\n    maxFeePerBlobGas,\n    maxFeePerGas,\n    maxPriorityFeePerGas,\n    nonce,\n    to,\n    value,\n    stateOverride,\n    ...rest\n  } = args\n  const account = account_ ? parseAccount(account_) : undefined\n\n  if (code && (factory || factoryData))\n    throw new BaseError(\n      'Cannot provide both `code` & `factory`/`factoryData` as parameters.',\n    )\n  if (code && to)\n    throw new BaseError('Cannot provide both `code` & `to` as parameters.')\n\n  // Check if the call is deployless via bytecode.\n  const deploylessCallViaBytecode = code && data_\n  // Check if the call is deployless via a factory.\n  const deploylessCallViaFactory = factory && factoryData && to && data_\n  const deploylessCall = deploylessCallViaBytecode || deploylessCallViaFactory\n\n  const data = (() => {\n    if (deploylessCallViaBytecode)\n      return toDeploylessCallViaBytecodeData({\n        code,\n        data: data_,\n      })\n    if (deploylessCallViaFactory)\n      return toDeploylessCallViaFactoryData({\n        data: data_,\n        factory,\n        factoryData,\n        to,\n      })\n    return data_\n  })()\n\n  try {\n    assertRequest(args as AssertRequestParameters)\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const rpcStateOverride = serializeStateOverride(stateOverride)\n\n    const chainFormat = client.chain?.formatters?.transactionRequest?.format\n    const format = chainFormat || formatTransactionRequest\n\n    const request = format({\n      // Pick out extra data that might exist on the chain's transaction request type.\n      ...extract(rest, { format: chainFormat }),\n      from: account?.address,\n      accessList,\n      blobs,\n      data,\n      gas,\n      gasPrice,\n      maxFeePerBlobGas,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      nonce,\n      to: deploylessCall ? undefined : to,\n      value,\n    } as TransactionRequest) as TransactionRequest\n\n    if (batch && shouldPerformMulticall({ request }) && !rpcStateOverride) {\n      try {\n        return await scheduleMulticall(client, {\n          ...request,\n          blockNumber,\n          blockTag,\n        } as unknown as ScheduleMulticallParameters<chain>)\n      } catch (err) {\n        if (\n          !(err instanceof ClientChainNotConfiguredError) &&\n          !(err instanceof ChainDoesNotSupportContract)\n        )\n          throw err\n      }\n    }\n\n    const response = await client.request({\n      method: 'eth_call',\n      params: rpcStateOverride\n        ? [\n            request as ExactPartial<RpcTransactionRequest>,\n            block,\n            rpcStateOverride,\n          ]\n        : [request as ExactPartial<RpcTransactionRequest>, block],\n    })\n    if (response === '0x') return { data: undefined }\n    return { data: response }\n  } catch (err) {\n    const data = getRevertErrorData(err)\n\n    // Check for CCIP-Read offchain lookup signature.\n    const { offchainLookup, offchainLookupSignature } = await import(\n      '../../utils/ccip.js'\n    )\n    if (\n      client.ccipRead !== false &&\n      data?.slice(0, 10) === offchainLookupSignature &&\n      to\n    )\n      return { data: await offchainLookup(client, { data, to }) }\n\n    // Check for counterfactual deployment error.\n    if (deploylessCall && data?.slice(0, 10) === '0x101bb98d')\n      throw new CounterfactualDeploymentFailedError({ factory })\n\n    throw getCallError(err as ErrorType, {\n      ...args,\n      account,\n      chain: client.chain,\n    })\n  }\n}\n\n// We only want to perform a scheduled multicall if:\n// - The request has calldata,\n// - The request has a target address,\n// - The target address is not already the aggregate3 signature,\n// - The request has no other properties (`nonce`, `gas`, etc cannot be sent with a multicall).\nfunction shouldPerformMulticall({ request }: { request: TransactionRequest }) {\n  const { data, to, ...request_ } = request\n  if (!data) return false\n  if (data.startsWith(aggregate3Signature)) return false\n  if (!to) return false\n  if (\n    Object.values(request_).filter((x) => typeof x !== 'undefined').length > 0\n  )\n    return false\n  return true\n}\n\ntype ScheduleMulticallParameters<chain extends Chain | undefined> = Pick<\n  CallParameters<chain>,\n  'blockNumber' | 'blockTag'\n> & {\n  data: Hex\n  multicallAddress?: Address | undefined\n  to: Address\n}\n\ntype ScheduleMulticallErrorType =\n  | GetChainContractAddressErrorType\n  | NumberToHexErrorType\n  | CreateBatchSchedulerErrorType\n  | EncodeFunctionDataErrorType\n  | DecodeFunctionResultErrorType\n  | RawContractErrorType\n  | ErrorType\n\nasync function scheduleMulticall<chain extends Chain | undefined>(\n  client: Client<Transport>,\n  args: ScheduleMulticallParameters<chain>,\n) {\n  const { batchSize = 1024, wait = 0 } =\n    typeof client.batch?.multicall === 'object' ? client.batch.multicall : {}\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    data,\n    multicallAddress: multicallAddress_,\n    to,\n  } = args\n\n  let multicallAddress = multicallAddress_\n  if (!multicallAddress) {\n    if (!client.chain) throw new ClientChainNotConfiguredError()\n\n    multicallAddress = getChainContractAddress({\n      blockNumber,\n      chain: client.chain,\n      contract: 'multicall3',\n    })\n  }\n\n  const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n  const block = blockNumberHex || blockTag\n\n  const { schedule } = createBatchScheduler({\n    id: `${client.uid}.${block}`,\n    wait,\n    shouldSplitBatch(args) {\n      const size = args.reduce((size, { data }) => size + (data.length - 2), 0)\n      return size > batchSize * 2\n    },\n    fn: async (\n      requests: {\n        data: Hex\n        to: Address\n      }[],\n    ) => {\n      const calls = requests.map((request) => ({\n        allowFailure: true,\n        callData: request.data,\n        target: request.to,\n      }))\n\n      const calldata = encodeFunctionData({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n      })\n\n      const data = await client.request({\n        method: 'eth_call',\n        params: [\n          {\n            data: calldata,\n            to: multicallAddress,\n          },\n          block,\n        ],\n      })\n\n      return decodeFunctionResult({\n        abi: multicall3Abi,\n        args: [calls],\n        functionName: 'aggregate3',\n        data: data || '0x',\n      })\n    },\n  })\n\n  const [{ returnData, success }] = await schedule({ data, to })\n\n  if (!success) throw new RawContractError({ data: returnData })\n  if (returnData === '0x') return { data: undefined }\n  return { data: returnData }\n}\n\ntype ToDeploylessCallViaBytecodeDataErrorType =\n  | EncodeDeployDataErrorType\n  | ErrorType\n\nfunction toDeploylessCallViaBytecodeData(parameters: {\n  code: Hex\n  data: Hex\n}) {\n  const { code, data } = parameters\n  return encodeDeployData({\n    abi: parseAbi(['constructor(bytes, bytes)']),\n    bytecode: deploylessCallViaBytecodeBytecode,\n    args: [code, data],\n  })\n}\n\ntype ToDeploylessCallViaFactoryDataErrorType =\n  | EncodeDeployDataErrorType\n  | ErrorType\n\nfunction toDeploylessCallViaFactoryData(parameters: {\n  data: Hex\n  factory: Address\n  factoryData: Hex\n  to: Address\n}) {\n  const { data, factory, factoryData, to } = parameters\n  return encodeDeployData({\n    abi: parseAbi(['constructor(address, bytes, address, bytes)']),\n    bytecode: deploylessCallViaFactoryBytecode,\n    args: [to, data, factory, factoryData],\n  })\n}\n\n/** @internal */\nexport type GetRevertErrorDataErrorType = ErrorType\n\n/** @internal */\nexport function getRevertErrorData(err: unknown) {\n  if (!(err instanceof BaseError)) return undefined\n  const error = err.walk() as RawContractError\n  return typeof error?.data === 'object' ? error.data?.data : error.data\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}