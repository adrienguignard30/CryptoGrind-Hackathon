{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.simulateBlocks = simulateBlocks;\nconst BlockOverrides = require(\"ox/BlockOverrides\");\nconst parseAccount_js_1 = require(\"../../accounts/utils/parseAccount.js\");\nconst abi_js_1 = require(\"../../errors/abi.js\");\nconst contract_js_1 = require(\"../../errors/contract.js\");\nconst node_js_1 = require(\"../../errors/node.js\");\nconst decodeFunctionResult_js_1 = require(\"../../utils/abi/decodeFunctionResult.js\");\nconst encodeFunctionData_js_1 = require(\"../../utils/abi/encodeFunctionData.js\");\nconst toHex_js_1 = require(\"../../utils/encoding/toHex.js\");\nconst getContractError_js_1 = require(\"../../utils/errors/getContractError.js\");\nconst getNodeError_js_1 = require(\"../../utils/errors/getNodeError.js\");\nconst block_js_1 = require(\"../../utils/formatters/block.js\");\nconst log_js_1 = require(\"../../utils/formatters/log.js\");\nconst transactionRequest_js_1 = require(\"../../utils/formatters/transactionRequest.js\");\nconst stateOverride_js_1 = require(\"../../utils/stateOverride.js\");\nconst assertRequest_js_1 = require(\"../../utils/transaction/assertRequest.js\");\nasync function simulateBlocks(client, parameters) {\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    blocks,\n    returnFullTransactions,\n    traceTransfers,\n    validation\n  } = parameters;\n  try {\n    const blockStateCalls = [];\n    for (const block of blocks) {\n      const blockOverrides = block.blockOverrides ? BlockOverrides.toRpc(block.blockOverrides) : undefined;\n      const calls = block.calls.map(call_ => {\n        const call = call_;\n        const account = call.account ? (0, parseAccount_js_1.parseAccount)(call.account) : undefined;\n        const request = {\n          ...call,\n          data: call.abi ? (0, encodeFunctionData_js_1.encodeFunctionData)(call) : call.data,\n          from: call.from ?? account?.address\n        };\n        (0, assertRequest_js_1.assertRequest)(request);\n        return (0, transactionRequest_js_1.formatTransactionRequest)(request);\n      });\n      const stateOverrides = block.stateOverrides ? (0, stateOverride_js_1.serializeStateOverride)(block.stateOverrides) : undefined;\n      blockStateCalls.push({\n        blockOverrides,\n        calls,\n        stateOverrides\n      });\n    }\n    const blockNumberHex = blockNumber ? (0, toHex_js_1.numberToHex)(blockNumber) : undefined;\n    const block = blockNumberHex || blockTag;\n    const result = await client.request({\n      method: 'eth_simulateV1',\n      params: [{\n        blockStateCalls,\n        returnFullTransactions,\n        traceTransfers,\n        validation\n      }, block]\n    });\n    return result.map((block, i) => ({\n      ...(0, block_js_1.formatBlock)(block),\n      calls: block.calls.map((call, j) => {\n        const {\n          abi,\n          args,\n          functionName,\n          to\n        } = blocks[i].calls[j];\n        const data = call.error?.data ?? call.returnData;\n        const gasUsed = BigInt(call.gasUsed);\n        const logs = call.logs?.map(log => (0, log_js_1.formatLog)(log));\n        const status = call.status === '0x1' ? 'success' : 'failure';\n        const result = abi && status === 'success' && data !== '0x' ? (0, decodeFunctionResult_js_1.decodeFunctionResult)({\n          abi,\n          data,\n          functionName\n        }) : null;\n        const error = (() => {\n          if (status === 'success') return undefined;\n          let error = undefined;\n          if (call.error?.data === '0x') error = new abi_js_1.AbiDecodingZeroDataError();else if (call.error) error = new contract_js_1.RawContractError(call.error);\n          if (!error) return undefined;\n          return (0, getContractError_js_1.getContractError)(error, {\n            abi: abi ?? [],\n            address: to,\n            args,\n            functionName: functionName ?? '<unknown>'\n          });\n        })();\n        return {\n          data,\n          gasUsed,\n          logs,\n          status,\n          ...(status === 'success' ? {\n            result\n          } : {\n            error\n          })\n        };\n      })\n    }));\n  } catch (e) {\n    const cause = e;\n    const error = (0, getNodeError_js_1.getNodeError)(cause, {});\n    if (error instanceof node_js_1.UnknownNodeError) throw cause;\n    throw error;\n  }\n}","map":{"version":3,"names":["exports","simulateBlocks","BlockOverrides","require","parseAccount_js_1","abi_js_1","contract_js_1","node_js_1","decodeFunctionResult_js_1","encodeFunctionData_js_1","toHex_js_1","getContractError_js_1","getNodeError_js_1","block_js_1","log_js_1","transactionRequest_js_1","stateOverride_js_1","assertRequest_js_1","client","parameters","blockNumber","blockTag","blocks","returnFullTransactions","traceTransfers","validation","blockStateCalls","block","blockOverrides","toRpc","undefined","calls","map","call_","call","account","parseAccount","request","data","abi","encodeFunctionData","from","address","assertRequest","formatTransactionRequest","stateOverrides","serializeStateOverride","push","blockNumberHex","numberToHex","result","method","params","i","formatBlock","j","args","functionName","to","error","returnData","gasUsed","BigInt","logs","log","formatLog","status","decodeFunctionResult","AbiDecodingZeroDataError","RawContractError","getContractError","e","cause","getNodeError","UnknownNodeError"],"sources":["C:\\Users\\Adrien\\Desktop\\CryptoGrind - Copie\\client\\node_modules\\viem\\actions\\public\\simulateBlocks.ts"],"sourcesContent":["import type { Abi, AbiStateMutability, Address, Narrow } from 'abitype'\nimport * as BlockOverrides from 'ox/BlockOverrides'\n\nimport {\n  type ParseAccountErrorType,\n  parseAccount,\n} from '../../accounts/utils/parseAccount.js'\nimport type { Client } from '../../clients/createClient.js'\nimport type { Transport } from '../../clients/transports/createTransport.js'\nimport { AbiDecodingZeroDataError } from '../../errors/abi.js'\nimport type { BaseError } from '../../errors/base.js'\nimport { RawContractError } from '../../errors/contract.js'\nimport { UnknownNodeError } from '../../errors/node.js'\nimport type { ErrorType } from '../../errors/utils.js'\nimport type { Account } from '../../types/account.js'\nimport type { Block, BlockTag } from '../../types/block.js'\nimport type { Call, Calls } from '../../types/calls.js'\nimport type { Chain } from '../../types/chain.js'\nimport type { Log } from '../../types/log.js'\nimport type { Hex } from '../../types/misc.js'\nimport type { MulticallResults } from '../../types/multicall.js'\nimport type { StateOverride } from '../../types/stateOverride.js'\nimport type { TransactionRequest } from '../../types/transaction.js'\nimport type { ExactPartial, UnionOmit } from '../../types/utils.js'\nimport {\n  type DecodeFunctionResultErrorType,\n  decodeFunctionResult,\n} from '../../utils/abi/decodeFunctionResult.js'\nimport {\n  type EncodeFunctionDataErrorType,\n  encodeFunctionData,\n} from '../../utils/abi/encodeFunctionData.js'\nimport {\n  type NumberToHexErrorType,\n  numberToHex,\n} from '../../utils/encoding/toHex.js'\nimport { getContractError } from '../../utils/errors/getContractError.js'\nimport {\n  type GetNodeErrorReturnType,\n  getNodeError,\n} from '../../utils/errors/getNodeError.js'\nimport {\n  type FormatBlockErrorType,\n  formatBlock,\n} from '../../utils/formatters/block.js'\nimport { formatLog } from '../../utils/formatters/log.js'\nimport {\n  type FormatTransactionRequestErrorType,\n  formatTransactionRequest,\n} from '../../utils/formatters/transactionRequest.js'\nimport {\n  type SerializeStateOverrideErrorType,\n  serializeStateOverride,\n} from '../../utils/stateOverride.js'\nimport {\n  type AssertRequestErrorType,\n  assertRequest,\n} from '../../utils/transaction/assertRequest.js'\n\ntype CallExtraProperties = ExactPartial<\n  UnionOmit<\n    TransactionRequest,\n    'blobs' | 'data' | 'kzg' | 'to' | 'sidecars' | 'value'\n  >\n> & {\n  /** Account attached to the call (msg.sender). */\n  account?: Account | Address | undefined\n}\n\nexport type SimulateBlocksParameters<\n  calls extends readonly unknown[] = readonly unknown[],\n> = {\n  /** Blocks to simulate. */\n  blocks: readonly {\n    /** Block overrides. */\n    blockOverrides?: BlockOverrides.BlockOverrides | undefined\n    /** Calls to execute. */\n    calls: Calls<Narrow<calls>, CallExtraProperties>\n    /** State overrides. */\n    stateOverrides?: StateOverride | undefined\n  }[]\n  /** Whether to return the full transactions. */\n  returnFullTransactions?: boolean | undefined\n  /** Whether to trace transfers. */\n  traceTransfers?: boolean | undefined\n  /** Whether to enable validation mode. */\n  validation?: boolean | undefined\n} & (\n  | {\n      /** The balance of the account at a block number. */\n      blockNumber?: bigint | undefined\n      blockTag?: undefined\n    }\n  | {\n      blockNumber?: undefined\n      /**\n       * The balance of the account at a block tag.\n       * @default 'latest'\n       */\n      blockTag?: BlockTag | undefined\n    }\n)\n\nexport type SimulateBlocksReturnType<\n  calls extends readonly unknown[] = readonly unknown[],\n> = readonly (Block & {\n  calls: MulticallResults<\n    Narrow<calls>,\n    true,\n    {\n      extraProperties: {\n        data: Hex\n        gasUsed: bigint\n        logs?: Log[] | undefined\n      }\n      error: Error\n      mutability: AbiStateMutability\n    }\n  >\n})[]\n\nexport type SimulateBlocksErrorType =\n  | AssertRequestErrorType\n  | DecodeFunctionResultErrorType\n  | EncodeFunctionDataErrorType\n  | FormatBlockErrorType\n  | FormatTransactionRequestErrorType\n  | GetNodeErrorReturnType\n  | ParseAccountErrorType\n  | SerializeStateOverrideErrorType\n  | NumberToHexErrorType\n  | ErrorType\n\n/**\n * Simulates a set of calls on block(s) with optional block and state overrides.\n *\n * @example\n * ```ts\n * import { createClient, http, parseEther } from 'viem'\n * import { simulate } from 'viem/actions'\n * import { mainnet } from 'viem/chains'\n *\n * const client = createClient({\n *   chain: mainnet,\n *   transport: http(),\n * })\n *\n * const result = await simulate(client, {\n *   blocks: [{\n *     blockOverrides: {\n *       number: 69420n,\n *     },\n *     calls: [{\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         data: '0xdeadbeef',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *       },\n *       {\n *         account: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *         to: '0x70997970c51812dc3a010c7d01b50e0d17dc79c8',\n *         value: parseEther('1'),\n *       },\n *     }],\n *     stateOverrides: [{\n *       address: '0x5a0b54d5dc17e482fe8b0bdca5320161b95fb929',\n *       balance: parseEther('10'),\n *     }],\n *   }]\n * })\n * ```\n *\n * @param client - Client to use.\n * @param parameters - {@link SimulateBlocksParameters}\n * @returns Simulated blocks. {@link SimulateBlocksReturnType}\n */\nexport async function simulateBlocks<\n  chain extends Chain | undefined,\n  const calls extends readonly unknown[],\n>(\n  client: Client<Transport, chain>,\n  parameters: SimulateBlocksParameters<calls>,\n): Promise<SimulateBlocksReturnType<calls>> {\n  const {\n    blockNumber,\n    blockTag = 'latest',\n    blocks,\n    returnFullTransactions,\n    traceTransfers,\n    validation,\n  } = parameters\n\n  try {\n    const blockStateCalls = []\n    for (const block of blocks) {\n      const blockOverrides = block.blockOverrides\n        ? BlockOverrides.toRpc(block.blockOverrides)\n        : undefined\n      const calls = block.calls.map((call_) => {\n        const call = call_ as Call<unknown, CallExtraProperties>\n        const account = call.account ? parseAccount(call.account) : undefined\n        const request = {\n          ...call,\n          data: call.abi ? encodeFunctionData(call) : call.data,\n          from: call.from ?? account?.address,\n        } as const\n        assertRequest(request)\n        return formatTransactionRequest(request)\n      })\n      const stateOverrides = block.stateOverrides\n        ? serializeStateOverride(block.stateOverrides)\n        : undefined\n\n      blockStateCalls.push({\n        blockOverrides,\n        calls,\n        stateOverrides,\n      })\n    }\n\n    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : undefined\n    const block = blockNumberHex || blockTag\n\n    const result = await client.request({\n      method: 'eth_simulateV1',\n      params: [\n        { blockStateCalls, returnFullTransactions, traceTransfers, validation },\n        block,\n      ],\n    })\n\n    return result.map((block, i) => ({\n      ...formatBlock(block),\n      calls: block.calls.map((call, j) => {\n        const { abi, args, functionName, to } = blocks[i].calls[j] as Call<\n          unknown,\n          CallExtraProperties\n        >\n\n        const data = call.error?.data ?? call.returnData\n        const gasUsed = BigInt(call.gasUsed)\n        const logs = call.logs?.map((log) => formatLog(log))\n        const status = call.status === '0x1' ? 'success' : 'failure'\n\n        const result =\n          abi && status === 'success' && data !== '0x'\n            ? decodeFunctionResult({\n                abi,\n                data,\n                functionName,\n              })\n            : null\n\n        const error = (() => {\n          if (status === 'success') return undefined\n\n          let error = undefined\n          if (call.error?.data === '0x') error = new AbiDecodingZeroDataError()\n          else if (call.error) error = new RawContractError(call.error)\n\n          if (!error) return undefined\n          return getContractError(error, {\n            abi: (abi ?? []) as Abi,\n            address: to,\n            args,\n            functionName: functionName ?? '<unknown>',\n          })\n        })()\n\n        return {\n          data,\n          gasUsed,\n          logs,\n          status,\n          ...(status === 'success'\n            ? {\n                result,\n              }\n            : {\n                error,\n              }),\n        }\n      }),\n    })) as unknown as SimulateBlocksReturnType<calls>\n  } catch (e) {\n    const cause = e as BaseError\n    const error = getNodeError(cause, {})\n    if (error instanceof UnknownNodeError) throw cause\n    throw error\n  }\n}\n"],"mappings":";;;;;AAgLAA,OAAA,CAAAC,cAAA,GAAAA,cAAA;AA/KA,MAAAC,cAAA,GAAAC,OAAA;AAEA,MAAAC,iBAAA,GAAAD,OAAA;AAMA,MAAAE,QAAA,GAAAF,OAAA;AAEA,MAAAG,aAAA,GAAAH,OAAA;AACA,MAAAI,SAAA,GAAAJ,OAAA;AAYA,MAAAK,yBAAA,GAAAL,OAAA;AAIA,MAAAM,uBAAA,GAAAN,OAAA;AAIA,MAAAO,UAAA,GAAAP,OAAA;AAIA,MAAAQ,qBAAA,GAAAR,OAAA;AACA,MAAAS,iBAAA,GAAAT,OAAA;AAIA,MAAAU,UAAA,GAAAV,OAAA;AAIA,MAAAW,QAAA,GAAAX,OAAA;AACA,MAAAY,uBAAA,GAAAZ,OAAA;AAIA,MAAAa,kBAAA,GAAAb,OAAA;AAIA,MAAAc,kBAAA,GAAAd,OAAA;AA0HO,eAAeF,cAAcA,CAIlCiB,MAAgC,EAChCC,UAA2C;EAE3C,MAAM;IACJC,WAAW;IACXC,QAAQ,GAAG,QAAQ;IACnBC,MAAM;IACNC,sBAAsB;IACtBC,cAAc;IACdC;EAAU,CACX,GAAGN,UAAU;EAEd,IAAI;IACF,MAAMO,eAAe,GAAG,EAAE;IAC1B,KAAK,MAAMC,KAAK,IAAIL,MAAM,EAAE;MAC1B,MAAMM,cAAc,GAAGD,KAAK,CAACC,cAAc,GACvC1B,cAAc,CAAC2B,KAAK,CAACF,KAAK,CAACC,cAAc,CAAC,GAC1CE,SAAS;MACb,MAAMC,KAAK,GAAGJ,KAAK,CAACI,KAAK,CAACC,GAAG,CAAEC,KAAK,IAAI;QACtC,MAAMC,IAAI,GAAGD,KAA2C;QACxD,MAAME,OAAO,GAAGD,IAAI,CAACC,OAAO,GAAG,IAAA/B,iBAAA,CAAAgC,YAAY,EAACF,IAAI,CAACC,OAAO,CAAC,GAAGL,SAAS;QACrE,MAAMO,OAAO,GAAG;UACd,GAAGH,IAAI;UACPI,IAAI,EAAEJ,IAAI,CAACK,GAAG,GAAG,IAAA9B,uBAAA,CAAA+B,kBAAkB,EAACN,IAAI,CAAC,GAAGA,IAAI,CAACI,IAAI;UACrDG,IAAI,EAAEP,IAAI,CAACO,IAAI,IAAIN,OAAO,EAAEO;SACpB;QACV,IAAAzB,kBAAA,CAAA0B,aAAa,EAACN,OAAO,CAAC;QACtB,OAAO,IAAAtB,uBAAA,CAAA6B,wBAAwB,EAACP,OAAO,CAAC;MAC1C,CAAC,CAAC;MACF,MAAMQ,cAAc,GAAGlB,KAAK,CAACkB,cAAc,GACvC,IAAA7B,kBAAA,CAAA8B,sBAAsB,EAACnB,KAAK,CAACkB,cAAc,CAAC,GAC5Cf,SAAS;MAEbJ,eAAe,CAACqB,IAAI,CAAC;QACnBnB,cAAc;QACdG,KAAK;QACLc;OACD,CAAC;IACJ;IAEA,MAAMG,cAAc,GAAG5B,WAAW,GAAG,IAAAV,UAAA,CAAAuC,WAAW,EAAC7B,WAAW,CAAC,GAAGU,SAAS;IACzE,MAAMH,KAAK,GAAGqB,cAAc,IAAI3B,QAAQ;IAExC,MAAM6B,MAAM,GAAG,MAAMhC,MAAM,CAACmB,OAAO,CAAC;MAClCc,MAAM,EAAE,gBAAgB;MACxBC,MAAM,EAAE,CACN;QAAE1B,eAAe;QAAEH,sBAAsB;QAAEC,cAAc;QAAEC;MAAU,CAAE,EACvEE,KAAK;KAER,CAAC;IAEF,OAAOuB,MAAM,CAAClB,GAAG,CAAC,CAACL,KAAK,EAAE0B,CAAC,MAAM;MAC/B,GAAG,IAAAxC,UAAA,CAAAyC,WAAW,EAAC3B,KAAK,CAAC;MACrBI,KAAK,EAAEJ,KAAK,CAACI,KAAK,CAACC,GAAG,CAAC,CAACE,IAAI,EAAEqB,CAAC,KAAI;QACjC,MAAM;UAAEhB,GAAG;UAAEiB,IAAI;UAAEC,YAAY;UAAEC;QAAE,CAAE,GAAGpC,MAAM,CAAC+B,CAAC,CAAC,CAACtB,KAAK,CAACwB,CAAC,CAGxD;QAED,MAAMjB,IAAI,GAAGJ,IAAI,CAACyB,KAAK,EAAErB,IAAI,IAAIJ,IAAI,CAAC0B,UAAU;QAChD,MAAMC,OAAO,GAAGC,MAAM,CAAC5B,IAAI,CAAC2B,OAAO,CAAC;QACpC,MAAME,IAAI,GAAG7B,IAAI,CAAC6B,IAAI,EAAE/B,GAAG,CAAEgC,GAAG,IAAK,IAAAlD,QAAA,CAAAmD,SAAS,EAACD,GAAG,CAAC,CAAC;QACpD,MAAME,MAAM,GAAGhC,IAAI,CAACgC,MAAM,KAAK,KAAK,GAAG,SAAS,GAAG,SAAS;QAE5D,MAAMhB,MAAM,GACVX,GAAG,IAAI2B,MAAM,KAAK,SAAS,IAAI5B,IAAI,KAAK,IAAI,GACxC,IAAA9B,yBAAA,CAAA2D,oBAAoB,EAAC;UACnB5B,GAAG;UACHD,IAAI;UACJmB;SACD,CAAC,GACF,IAAI;QAEV,MAAME,KAAK,GAAG,CAAC,MAAK;UAClB,IAAIO,MAAM,KAAK,SAAS,EAAE,OAAOpC,SAAS;UAE1C,IAAI6B,KAAK,GAAG7B,SAAS;UACrB,IAAII,IAAI,CAACyB,KAAK,EAAErB,IAAI,KAAK,IAAI,EAAEqB,KAAK,GAAG,IAAItD,QAAA,CAAA+D,wBAAwB,EAAE,MAChE,IAAIlC,IAAI,CAACyB,KAAK,EAAEA,KAAK,GAAG,IAAIrD,aAAA,CAAA+D,gBAAgB,CAACnC,IAAI,CAACyB,KAAK,CAAC;UAE7D,IAAI,CAACA,KAAK,EAAE,OAAO7B,SAAS;UAC5B,OAAO,IAAAnB,qBAAA,CAAA2D,gBAAgB,EAACX,KAAK,EAAE;YAC7BpB,GAAG,EAAGA,GAAG,IAAI,EAAU;YACvBG,OAAO,EAAEgB,EAAE;YACXF,IAAI;YACJC,YAAY,EAAEA,YAAY,IAAI;WAC/B,CAAC;QACJ,CAAC,EAAC,CAAE;QAEJ,OAAO;UACLnB,IAAI;UACJuB,OAAO;UACPE,IAAI;UACJG,MAAM;UACN,IAAIA,MAAM,KAAK,SAAS,GACpB;YACEhB;WACD,GACD;YACES;WACD;SACN;MACH,CAAC;KACF,CAAC,CAA+C;EACnD,CAAC,CAAC,OAAOY,CAAC,EAAE;IACV,MAAMC,KAAK,GAAGD,CAAc;IAC5B,MAAMZ,KAAK,GAAG,IAAA/C,iBAAA,CAAA6D,YAAY,EAACD,KAAK,EAAE,EAAE,CAAC;IACrC,IAAIb,KAAK,YAAYpD,SAAA,CAAAmE,gBAAgB,EAAE,MAAMF,KAAK;IAClD,MAAMb,KAAK;EACb;AACF","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}